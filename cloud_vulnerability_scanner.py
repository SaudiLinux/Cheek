#!/usr/bin/env python3
"""
Cloud Vulnerability Scanner
A comprehensive tool for identifying cloud security vulnerabilities
across multiple cloud platforms and services
"""

import json
import argparse
import datetime
import sys
import os
import threading
import queue
import time
import socket
import ssl
import requests
from typing import Dict, List, Optional, Any, Tuple
from urllib.parse import urlparse, urljoin
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor, as_completed

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    from exploits.cloud_exploits import CloudExploits
    from exploits.web_exploits import WebExploits
    from exploits.modern_vulnerabilities import ModernVulnerabilities
except ImportError as e:
    print(f"Import error: {e}")
    print("Make sure required modules are available in exploits/ directory")
    sys.exit(1)

class CloudVulnerabilityScanner:
    """
    Comprehensive cloud vulnerability scanner supporting multiple cloud platforms
    """
    
    def __init__(self, target: str, threads: int = 10, timeout: int = 30, 
                 output_dir: str = "reports", verbose: bool = False):
        self.target = target
        self.threads = threads
        self.timeout = timeout
        self.output_dir = output_dir
        self.verbose = verbose
        
        # Initialize exploit modules
        self.cloud_exploits = CloudExploits(target)
        self.web_exploits = WebExploits(target)
        self.modern_exploits = ModernVulnerabilities(target)
        
        # Results storage
        self.findings = []
        self.vulnerabilities = []
        self.warnings = []
        self.info = []
        
        # Thread-safe result storage
        self.results_lock = threading.Lock()
        
        # Create output directory
        os.makedirs(output_dir, exist_ok=True)
        
        # Cloud service patterns
        self.cloud_patterns = {
            'aws': {
                's3': [
                    f'https://{target}.s3.amazonaws.com',
                    f'https://s3.amazonaws.com/{target}',
                    f'https://{target}-backup.s3.amazonaws.com',
                    f'https://{target}-data.s3.amazonaws.com',
                    f'https://{target}-logs.s3.amazonaws.com'
                ],
                'cloudfront': [
                    f'https://{target}.cloudfront.net',
                    f'https://d111111abcdef8.cloudfront.net'  # Generic pattern
                ],
                'elastic_beanstalk': [
                    f'http://{target}.elasticbeanstalk.com',
                    f'http://{target}.us-east-1.elasticbeanstalk.com'
                ],
                'api_gateway': [
                    f'https://{target}.execute-api.us-east-1.amazonaws.com',
                    f'https://{target}.execute-api.*.amazonaws.com'
                ]
            },
            'azure': {
                'blob_storage': [
                    f'https://{target}.blob.core.windows.net',
                    f'https://{target}storage.blob.core.windows.net',
                    f'https://{target}data.blob.core.windows.net'
                ],
                'app_service': [
                    f'https://{target}.azurewebsites.net',
                    f'https://{target}-app.azurewebsites.net'
                ],
                'function_app': [
                    f'https://{target}.azurewebsites.net',
                    f'https://{target}-functions.azurewebsites.net'
                ]
            },
            'gcp': {
                'cloud_storage': [
                    f'https://storage.googleapis.com/{target}',
                    f'https://{target}.storage.googleapis.com',
                    f'https://storage.cloud.google.com/{target}'
                ],
                'app_engine': [
                    f'https://{target}.appspot.com',
                    f'https://{target}-app.appspot.com'
                ],
                'cloud_functions': [
                    f'https://us-central1-{target}.cloudfunctions.net',
                    f'https://{target}.cloudfunctions.net'
                ]
            }
        }
        
        # Container platform patterns
        self.container_patterns = {
            'kubernetes': {
                'api_server': [
                    f'https://{target}:6443',
                    f'https://{target}:8443',
                    f'https://k8s.{target}:6443'
                ],
                'dashboard': [
                    f'https://{target}:30000',
                    f'https://dashboard.{target}',
                    f'https://kubernetes-dashboard.{target}'
                ],
                'etcd': [
                    f'https://{target}:2379',
                    f'https://etcd.{target}:2379'
                ]
            },
            'docker': {
                'daemon': [
                    f'tcp://{target}:2375',
                    f'tcp://{target}:2376'
                ],
                'registry': [
                    f'https://{target}:5000',
                    f'https://registry.{target}',
                    f'https://docker-registry.{target}'
                ]
            },
            'openshift': {
                'api': [
                    f'https://{target}:8443',
                    f'https://api.{target}:6443'
                ],
                'console': [
                    f'https://console.{target}:8443',
                    f'https://openshift-console.{target}'
                ]
            }
        }
    
    def log(self, message: str, level: str = "INFO"):
        """Enhanced logging with levels and colors"""
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        colors = {
            "INFO": "\033[94m",     # Blue
            "SUCCESS": "\033[92m",  # Green
            "WARNING": "\033[93m",  # Yellow
            "ERROR": "\033[91m",    # Red
            "CRITICAL": "\033[95m", # Magenta
            "RESET": "\033[0m"      # Reset
        }
        
        if self.verbose or level in ["ERROR", "CRITICAL", "SUCCESS"]:
            color = colors.get(level, "")
            reset = colors["RESET"]
            print(f"[{timestamp}] {color}[{level}]{reset} {message}")
    
    def check_endpoint(self, url: str, service_type: str, platform: str) -> Dict[str, Any]:
        """Check if a cloud service endpoint is accessible"""
        result = {
            "url": url,
            "service_type": service_type,
            "platform": platform,
            "accessible": False,
            "status_code": None,
            "vulnerabilities": [],
            "headers": {},
            "error": None
        }
        
        try:
            # Set appropriate headers for cloud services
            headers = {
                'User-Agent': 'Cloud-Vuln-Scanner/2.0',
                'Accept': '*/*',
                'Connection': 'keep-alive'
            }
            
            # Add service-specific headers
            if 's3' in service_type.lower():
                headers['x-amz-content-sha256'] = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
            elif 'azure' in platform.lower():
                headers['x-ms-version'] = '2020-10-02'
            elif 'gcp' in platform.lower():
                headers['x-goog-api-client'] = 'cloud-vuln-scanner'
            
            response = requests.get(url, headers=headers, timeout=self.timeout, 
                                  allow_redirects=True, verify=True)
            
            result["accessible"] = True
            result["status_code"] = response.status_code
            result["headers"] = dict(response.headers)
            
            # Analyze response for vulnerabilities
            self.analyze_response(result, response)
            
            self.log(f"âœ… {platform} {service_type} accessible: {url} (Status: {response.status_code})", "SUCCESS")
            
        except requests.exceptions.RequestException as e:
            result["error"] = str(e)
            self.log(f"âŒ {platform} {service_type} not accessible: {url} ({str(e)})", "WARNING")
        except Exception as e:
            result["error"] = str(e)
            self.log(f"âŒ Error checking {url}: {str(e)}", "ERROR")
        
        return result
    
    def analyze_response(self, result: Dict[str, Any], response: requests.Response):
        """Analyze HTTP response for security issues"""
        vulnerabilities = []
        
        # Check for common security headers
        security_headers = {
            'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
            'X-Frame-Options': 'Missing X-Frame-Options header',
            'X-XSS-Protection': 'Missing X-XSS-Protection header',
            'Strict-Transport-Security': 'Missing HSTS header',
            'Content-Security-Policy': 'Missing Content-Security-Policy header'
        }
        
        for header, message in security_headers.items():
            if header not in response.headers:
                vulnerabilities.append({
                    "type": "missing_security_header",
                    "header": header,
                    "severity": "MEDIUM",
                    "message": message,
                    "recommendation": f"Add {header} header to responses"
                })
        
        # Check for information disclosure
        server_header = response.headers.get('Server', '').lower()
        if server_header and any(tech in server_header for tech in ['apache', 'nginx', 'iis', 'tomcat']):
            vulnerabilities.append({
                "type": "server_information_disclosure",
                "severity": "LOW",
                "message": f"Server technology disclosed: {server_header}",
                "recommendation": "Remove or obfuscate server header"
            })
        
        # Check for cloud-specific issues
        if response.status_code == 403:
            vulnerabilities.append({
                "type": "access_denied_but_exists",
                "severity": "INFO",
                "message": "Resource exists but access is denied",
                "recommendation": "Review access permissions - resource may be overexposed"
            })
        elif response.status_code == 404:
            # Check for custom 404 pages that might reveal information
            if len(response.text) > 1000:
                vulnerabilities.append({
                    "type": "verbose_error_page",
                    "severity": "LOW",
                    "message": "Verbose error page may reveal system information",
                    "recommendation": "Use generic error pages"
                })
        
        result["vulnerabilities"] = vulnerabilities
    
    def scan_cloud_services(self) -> List[Dict[str, Any]]:
        """Scan for cloud service endpoints"""
        self.log("ğŸŒ©ï¸ Starting cloud service enumeration...")
        
        results = []
        endpoints_to_check = []
        
        # Build list of endpoints to check
        for platform, services in self.cloud_patterns.items():
            for service_type, urls in services.items():
                for url in urls:
                    endpoints_to_check.append((url, service_type, platform))
        
        # Scan endpoints using thread pool
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {
                executor.submit(self.check_endpoint, url, service_type, platform): (url, service_type, platform)
                for url, service_type, platform in endpoints_to_check
            }
            
            for future in as_completed(futures):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    url, service_type, platform = futures[future]
                    self.log(f"âŒ Error scanning {url}: {str(e)}", "ERROR")
        
        self.log(f"âœ… Cloud service enumeration completed. Found {len([r for r in results if r['accessible']])} accessible services.")
        return results
    
    def scan_container_platforms(self) -> List[Dict[str, Any]]:
        """Scan for container platform endpoints"""
        self.log("ğŸ³ Starting container platform enumeration...")
        
        results = []
        endpoints_to_check = []
        
        # Build list of container endpoints to check
        for platform, services in self.container_patterns.items():
            for service_type, urls in services.items():
                for url in urls:
                    endpoints_to_check.append((url, service_type, platform))
        
        # Scan endpoints using thread pool
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {
                executor.submit(self.check_endpoint, url, service_type, platform): (url, service_type, platform)
                for url, service_type, platform in endpoints_to_check
            }
            
            for future in as_completed(futures):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    url, service_type, platform = futures[future]
                    self.log(f"âŒ Error scanning {url}: {str(e)}", "ERROR")
        
        self.log(f"âœ… Container platform enumeration completed. Found {len([r for r in results if r['accessible']])} accessible services.")
        return results
    
    def run_advanced_vulnerability_tests(self) -> List[Dict[str, Any]]:
        """Run advanced vulnerability tests using exploit modules"""
        self.log("ğŸ”¬ Running advanced vulnerability tests...")
        
        results = []
        
        try:
            # Run cloud-specific tests
            if hasattr(self.cloud_exploits, 'run_all_exploits'):
                cloud_results = self.cloud_exploits.run_all_exploits()
                if cloud_results and isinstance(cloud_results, list):
                    results.extend(cloud_results)
                    self.log(f"âœ… Cloud exploitation tests completed", "SUCCESS")
                else:
                    self.log(f"â„¹ï¸  Cloud exploitation tests returned no findings", "INFO")
            else:
                self.log(f"â„¹ï¸  Cloud exploitation module not available, running basic tests", "INFO")
                # Run basic cloud tests
                basic_cloud_results = self.run_basic_cloud_tests()
                if basic_cloud_results:
                    results.extend(basic_cloud_results)
        except Exception as e:
            self.log(f"âŒ Cloud exploitation tests failed: {str(e)}", "ERROR")
        
        try:
            # Run web security tests
            if hasattr(self.web_exploits, 'run_all_exploits'):
                web_results = self.web_exploits.run_all_exploits()
                if web_results and isinstance(web_results, list):
                    results.extend(web_results)
                    self.log(f"âœ… Web security tests completed", "SUCCESS")
                else:
                    self.log(f"â„¹ï¸  Web security tests returned no findings", "INFO")
            else:
                self.log(f"â„¹ï¸  Web exploitation module not available", "INFO")
        except Exception as e:
            self.log(f"âŒ Web security tests failed: {str(e)}", "ERROR")
        
        try:
            # Run modern vulnerability tests
            if hasattr(self.modern_exploits, 'run_all_exploits'):
                modern_results = self.modern_exploits.run_all_exploits()
                if modern_results and isinstance(modern_results, list):
                    results.extend(modern_results)
                    self.log(f"âœ… Modern vulnerability tests completed", "SUCCESS")
                else:
                    self.log(f"â„¹ï¸  Modern vulnerability tests returned no findings", "INFO")
            else:
                self.log(f"â„¹ï¸  Modern vulnerability module not available", "INFO")
        except Exception as e:
            self.log(f"âŒ Modern vulnerability tests failed: {str(e)}", "ERROR")
        
        return results
    
    def assess_risk_level(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess overall risk level based on findings"""
        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0}
        
        for finding in findings:
            severity = finding.get("severity", "INFO").upper()
            if severity in severity_counts:
                severity_counts[severity] += 1
        
        # Calculate risk score
        critical = severity_counts["CRITICAL"]
        high = severity_counts["HIGH"]
        medium = severity_counts["MEDIUM"]
        
        if critical > 0:
            risk_level = "CRITICAL"
            risk_score = min(90 + critical * 5, 100)
        elif high > 0:
            risk_level = "HIGH"
            risk_score = min(70 + high * 5, 89)
        elif medium > 0:
            risk_level = "MEDIUM"
            risk_score = min(40 + medium * 3, 69)
        else:
            risk_level = "LOW"
            risk_score = min(10 + severity_counts["LOW"] * 2, 39)
        
        return {
            "risk_level": risk_level,
            "risk_score": risk_score,
            "severity_breakdown": severity_counts,
            "total_findings": sum(severity_counts.values()),
            "critical_findings": critical,
            "high_findings": high,
            "medium_findings": medium
        }
    
    def generate_recommendations(self, findings: List[Dict[str, Any]]) -> List[Dict[str, str]]:
        """Generate security recommendations based on findings"""
        recommendations = []
        
        # Group findings by category
        categories = {}
        for finding in findings:
            category = finding.get("category", "General")
            if category not in categories:
                categories[category] = []
            categories[category].append(finding)
        
        # Generate recommendations for each category
        for category, category_findings in categories.items():
            if category == "Cloud Storage":
                recommendations.append({
                    "priority": "HIGH",
                    "category": category,
                    "recommendation": "Implement comprehensive cloud storage security policies",
                    "details": "Review and restrict access permissions, enable encryption, implement bucket policies"
                })
            elif category == "Container Security":
                recommendations.append({
                    "priority": "CRITICAL",
                    "category": category,
                    "recommendation": "Secure container orchestration platforms",
                    "details": "Enable authentication, implement RBAC, secure API endpoints, use network policies"
                })
            elif category == "Web Security":
                recommendations.append({
                    "priority": "HIGH",
                    "category": category,
                    "recommendation": "Implement web application security headers",
                    "details": "Add security headers, implement CSP, enable HSTS, configure secure cookies"
                })
            elif category == "Secrets Management":
                recommendations.append({
                    "priority": "CRITICAL",
                    "category": category,
                    "recommendation": "Implement secure secrets management",
                    "details": "Use dedicated secret management services, rotate keys regularly, implement access controls"
                })
        
        # Always include general recommendations
        recommendations.extend([
            {
                "priority": "HIGH",
                "category": "General",
                "recommendation": "Implement continuous security monitoring",
                "details": "Deploy security monitoring tools and establish incident response procedures"
            },
            {
                "priority": "MEDIUM",
                "category": "General",
                "recommendation": "Regular security assessments",
                "details": "Conduct periodic vulnerability assessments and penetration testing"
            },
            {
                "priority": "MEDIUM",
                "category": "General",
                "recommendation": "Security awareness training",
                "details": "Provide security training for development and operations teams"
            }
        ])
        
        return recommendations
    
    def run_basic_cloud_tests(self) -> List[Dict[str, Any]]:
        """Run basic cloud security tests when advanced modules aren't available"""
        self.log("ğŸ” Running basic cloud security tests...")
        
        findings = []
        
        # Basic S3 bucket enumeration
        s3_buckets = [
            f"{self.target}",
            f"{self.target}-backup",
            f"{self.target}-data", 
            f"{self.target}-logs",
            f"{self.target}-assets"
        ]
        
        for bucket in s3_buckets:
            try:
                s3_url = f"https://{bucket}.s3.amazonaws.com"
                response = requests.head(s3_url, timeout=self.timeout)
                
                if response.status_code == 403:
                    findings.append({
                        "type": "s3_bucket_exists",
                        "bucket": bucket,
                        "severity": "INFO",
                        "message": f"S3 bucket '{bucket}' exists but is private",
                        "recommendation": "Review bucket permissions and ensure proper access controls",
                        "url": s3_url,
                        "category": "Cloud Storage"
                    })
                elif response.status_code == 200:
                    findings.append({
                        "type": "s3_bucket_public",
                        "bucket": bucket,
                        "severity": "HIGH",
                        "message": f"S3 bucket '{bucket}' is publicly accessible",
                        "recommendation": "Restrict bucket access and implement proper policies",
                        "url": s3_url,
                        "category": "Cloud Storage"
                    })
                    
            except Exception as e:
                self.log(f"S3 bucket check failed for {bucket}: {str(e)}", "WARNING")
        
        # Basic Azure storage check
        try:
            azure_url = f"https://{self.target}.blob.core.windows.net"
            response = requests.head(azure_url, timeout=self.timeout)
            
            if response.status_code in [200, 403]:
                severity = "HIGH" if response.status_code == 200 else "INFO"
                findings.append({
                    "type": "azure_blob_storage",
                    "severity": severity,
                    "message": f"Azure Blob Storage endpoint detected: {azure_url}",
                    "recommendation": "Review storage account permissions and access policies",
                    "url": azure_url,
                    "category": "Cloud Storage"
                })
                
        except Exception as e:
            self.log(f"Azure storage check failed: {str(e)}", "WARNING")
        
        # Basic GCP storage check
        try:
            gcp_url = f"https://storage.googleapis.com/{self.target}"
            response = requests.head(gcp_url, timeout=self.timeout)
            
            if response.status_code in [200, 403]:
                severity = "HIGH" if response.status_code == 200 else "INFO"
                findings.append({
                    "type": "gcp_cloud_storage",
                    "severity": severity,
                    "message": f"GCP Cloud Storage endpoint detected: {gcp_url}",
                    "recommendation": "Review bucket permissions and implement access controls",
                    "url": gcp_url,
                    "category": "Cloud Storage"
                })
                
        except Exception as e:
            self.log(f"GCP storage check failed: {str(e)}", "WARNING")
        
        self.log(f"âœ… Basic cloud tests completed. Found {len(findings)} potential issues.", "SUCCESS")
        return findings
    
    def run_comprehensive_scan(self) -> Dict[str, Any]:
        """Run comprehensive cloud vulnerability scan"""
        self.log(f"ğŸš€ Starting comprehensive cloud vulnerability scan for {self.target}")
        start_time = time.time()
        
        all_findings = []
        
        # Phase 1: Cloud Service Enumeration
        self.log("ğŸ“‹ Phase 1: Cloud Service Enumeration")
        cloud_services = self.scan_cloud_services()
        
        # Extract vulnerabilities from cloud service scans
        for service in cloud_services:
            if service['accessible'] and service['vulnerabilities']:
                for vuln in service['vulnerabilities']:
                    vuln.update({
                        'service_url': service['url'],
                        'service_type': service['service_type'],
                        'platform': service['platform']
                    })
                    all_findings.append(vuln)
        
        # Phase 2: Container Platform Scanning
        self.log("ğŸ“‹ Phase 2: Container Platform Scanning")
        container_services = self.scan_container_platforms()
        
        # Extract vulnerabilities from container scans
        for service in container_services:
            if service['accessible'] and service['vulnerabilities']:
                for vuln in service['vulnerabilities']:
                    vuln.update({
                        'service_url': service['url'],
                        'service_type': service['service_type'],
                        'platform': service['platform']
                    })
                    all_findings.append(vuln)
        
        # Phase 3: Advanced Vulnerability Testing
        self.log("ğŸ“‹ Phase 3: Advanced Vulnerability Testing")
        advanced_findings = self.run_advanced_vulnerability_tests()
        all_findings.extend(advanced_findings)
        
        execution_time = time.time() - start_time
        
        # Risk Assessment
        risk_assessment = self.assess_risk_level(all_findings)
        
        # Generate Recommendations
        recommendations = self.generate_recommendations(all_findings)
        
        scan_result = {
            "scan_metadata": {
                "target": self.target,
                "scan_type": "comprehensive_cloud_vulnerability_scan",
                "scan_started": datetime.datetime.fromtimestamp(start_time).isoformat(),
                "scan_completed": datetime.datetime.now().isoformat(),
                "execution_time": execution_time,
                "threads_used": self.threads,
                "timeout": self.timeout,
                "scanner_version": "3.0.0"
            },
            "summary": {
                "total_findings": len(all_findings),
                "accessible_cloud_services": len([s for s in cloud_services if s['accessible']]),
                "accessible_container_services": len([s for s in container_services if s['accessible']]),
                "risk_assessment": risk_assessment
            },
            "cloud_services": cloud_services,
            "container_services": container_services,
            "vulnerabilities": all_findings,
            "recommendations": recommendations,
            "next_steps": self.generate_next_steps(risk_assessment, recommendations)
        }
        
        self.log(f"âœ… Comprehensive scan completed in {execution_time:.2f} seconds", "SUCCESS")
        self.log(f"ğŸ“Š Found {len(all_findings)} vulnerabilities across {len(cloud_services + container_services)} services")
        
        return scan_result
    
    def generate_next_steps(self, risk_assessment: Dict[str, Any], recommendations: List[Dict[str, str]]) -> List[str]:
        """Generate next steps for remediation"""
        next_steps = []
        
        risk_level = risk_assessment.get("risk_level", "LOW")
        
        if risk_level == "CRITICAL":
            next_steps.extend([
                "ğŸš¨ IMMEDIATE ACTION REQUIRED: Address all CRITICAL findings",
                "ğŸ”’ Implement emergency security measures",
                "ğŸ“ Contact security team and stakeholders",
                "ğŸ”„ Consider temporary service isolation if necessary",
                "ğŸ“‹ Document all findings for compliance reporting"
            ])
        elif risk_level == "HIGH":
            next_steps.extend([
                "âš ï¸  PRIORITY: Address HIGH severity findings within 24-48 hours",
                "ğŸ” Conduct detailed security review of affected systems",
                "ğŸ“Š Implement additional monitoring and alerting",
                "ğŸ›¡ï¸  Review and update security policies"
            ])
        elif risk_level == "MEDIUM":
            next_steps.extend([
                "ğŸ“… Schedule remediation of MEDIUM severity findings",
                "ğŸ”§ Implement security improvements based on recommendations",
                "ğŸ“ˆ Review security configurations and access controls",
                "ğŸ‘¥ Conduct security awareness training"
            ])
        
        # Always include these steps
        next_steps.extend([
            "ğŸ”„ Implement continuous security monitoring",
            "ğŸ“… Schedule regular vulnerability assessments",
            "ğŸ› ï¸  Keep all systems and dependencies updated",
            "ğŸ“š Follow cloud security best practices and compliance frameworks",
            "ğŸ” Implement defense-in-depth security strategy"
        ])
        
        return next_steps
    
    def save_report(self, scan_results: Dict[str, Any]) -> str:
        """Save scan results to JSON report"""
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        report_filename = f"cloud_vulnerability_scan_{self.target}_{timestamp}.json"
        report_path = os.path.join(self.output_dir, report_filename)
        
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(scan_results, f, indent=2, ensure_ascii=False, default=str)
        
        self.log(f"ğŸ“Š Report saved to: {report_path}", "SUCCESS")
        return report_path
    
    def print_summary(self, scan_results: Dict[str, Any]):
        """Print scan summary"""
        print("\n" + "="*80)
        print("ğŸŒ©ï¸ CLOUD VULNERABILITY SCAN SUMMARY")
        print("="*80)
        
        metadata = scan_results["scan_metadata"]
        summary = scan_results["summary"]
        risk_assessment = summary["risk_assessment"]
        
        print(f"ğŸ¯ Target: {metadata['target']}")
        print(f"â±ï¸  Execution Time: {metadata['execution_time']:.2f} seconds")
        print(f"ğŸ” Total Findings: {summary['total_findings']}")
        print(f"â˜ï¸  Cloud Services Found: {summary['accessible_cloud_services']}")
        print(f"ğŸ³ Container Services Found: {summary['accessible_container_services']}")
        
        print(f"\nğŸ¯ Risk Assessment:")
        print(f"   Risk Level: {risk_assessment['risk_level']}")
        print(f"   Risk Score: {risk_assessment['risk_score']}/100")
        
        if risk_assessment['total_findings'] > 0:
            print(f"\nğŸ“ˆ Severity Breakdown:")
            for severity, count in risk_assessment['severity_breakdown'].items():
                if count > 0:
                    print(f"   {severity}: {count}")
        
        print(f"\nğŸ’¡ Top Recommendations:")
        recommendations = scan_results.get("recommendations", [])
        for i, rec in enumerate(recommendations[:3], 1):
            print(f"   {i}. [{rec['priority']}] {rec['recommendation']}")
        
        print("\n" + "="*80)

def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Cloud Vulnerability Scanner - Comprehensive cloud security assessment tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python cloud_vulnerability_scanner.py target.com
  python cloud_vulnerability_scanner.py target.com --threads 5 --timeout 30
  python cloud_vulnerability_scanner.py target.com --verbose --output-dir custom_reports
  python cloud_vulnerability_scanner.py target.com --threads 10 --timeout 15
  python cloud_vulnerability_scanner.py target.com --quick-scan
        """
    )
    
    parser.add_argument("target", help="Target domain or IP address")
    parser.add_argument("--threads", 
                       type=int, 
                       default=10,
                       help="Number of threads for scanning (default: 10)")
    parser.add_argument("--timeout", 
                       type=int, 
                       default=30,
                       help="Request timeout in seconds (default: 30)")
    parser.add_argument("--output-dir", 
                       help="Output directory for reports (default: reports)",
                       default="reports")
    parser.add_argument("--verbose", 
                       action="store_true",
                       help="Enable verbose output")
    parser.add_argument("--quick-scan", 
                       action="store_true",
                       help="Perform quick scan with reduced timeout")
    parser.add_argument("--deep-scan", 
                       action="store_true",
                       help="Perform deep scan with extended timeout")
    
    args = parser.parse_args()
    
    # Adjust timeout based on scan type
    if args.quick_scan:
        args.timeout = 15
        args.threads = 20
    elif args.deep_scan:
        args.timeout = 60
        args.threads = 5
    
    print(f"ğŸŒ©ï¸ Cloud Vulnerability Scanner v3.0")
    print(f"ğŸ¯ Target: {args.target}")
    print(f"ğŸ§µ Threads: {args.threads}")
    print(f"â±ï¸  Timeout: {args.timeout}s")
    print(f"ğŸ“ Output Directory: {args.output_dir}")
    
    try:
        # Initialize scanner
        scanner = CloudVulnerabilityScanner(
            target=args.target,
            threads=args.threads,
            timeout=args.timeout,
            output_dir=args.output_dir,
            verbose=args.verbose
        )
        
        # Run comprehensive scan
        scan_results = scanner.run_comprehensive_scan()
        
        # Save report
        report_path = scanner.save_report(scan_results)
        
        # Print summary
        scanner.print_summary(scan_results)
        
        print(f"âœ… Cloud vulnerability scan completed successfully!")
        print(f"ğŸ“Š Detailed report saved to: {report_path}")
        
        return 0
        
    except KeyboardInterrupt:
        print(f"\nâš ï¸  Scan interrupted by user")
        return 1
    except Exception as e:
        print(f"âŒ Scan failed: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == "__main__":
    sys.exit(main())